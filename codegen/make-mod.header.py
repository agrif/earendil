#########################################
# THIS FILE IS GENERATED BY make-mod.py #
# DO NOT EDIT IT BY HAND, EDIT EITHER   #
# make-mod.py OR make-mod.header.py     #
# IN THE CODEGEN DIRECTORY, AND RE-GEN  #
#########################################

import typing
from .line import Line

#
# This file has been generated from the Earendil IRC Protocol Specification,
# version {major-version}.{minor-version}
#

class Message:
    __slots__ = ['source']

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> Line:
        raise NotImplementedError('Message.to_line')

    def to_raw(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> bytes:
        return self.to_line().to_raw()

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> 'Message':
        global from_lines_by_verb
        try:
            return from_lines_by_verb[line.command](line, decode)
        except Exception:
            return Unknown.from_line(line, decode)

    @classmethod
    def from_raw(cls, line: bytes, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> 'Message':
        return cls.from_line(Line.from_raw(line), decode)

class Unknown(Message):
    __slots__ = ['command', 'arguments']

    def __init__(self, source: str, command: typing.Union[bytes, int], arguments: typing.List[bytes]) -> None:
        self.source = source
        self.command = command
        self.arguments = arguments

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        return Line(source, self.command, self.arguments)

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> Message:
        source = None
        if line.source is not None:
            try:
                source = decode(line.source)
            except Exception:
                pass
        return cls(source, line.command, line.arguments)

    def __repr__(self) -> str:
        return "Unknown(source={{}}, command={{}}, arguments={{}})".format(repr(self.source), repr(self.command), repr(self.arguments))

#
# make-mod.header.py above ^
# make-mod.py generated code below v
#

