#########################################
# THIS FILE IS GENERATED BY make-mod.py #
# DO NOT EDIT IT BY HAND, EDIT EITHER   #
# make-mod.py OR make-mod.header.py     #
# IN THE CODEGEN DIRECTORY, AND RE-GEN  #
#########################################

import typing
from .line import Line, parse_line

#
# This file has been generated from the Earendil IRC Protocol Specification,
# version {major-version}.{minor-version}
#

class Message:
    __slots__ = ['source']

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> Line:
        raise NotImplementedError('Message.to_line')

    def to_raw(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> bytes:
        return self.to_line().to_raw()

class Unknown(Message):
    __slots__ = ['command', 'arguments']

    def __init__(self, source: str, command: typing.Union[bytes, int], arguments: typing.List[bytes]) -> None:
        self.source = source
        self.command = command
        self.arguments = arguments

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        return Line(source, self.command, self.arguments)

    def __repr__(self) -> str:
        return "Unknown(source={{}}, command={{}}, arguments={{}})".format(repr(self.source), repr(self.command), repr(self.arguments))

def parse_line_message(line: bytes, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> Message:
    return parse_message(parse_line(line), decode)

#
# make-mod.header.py above ^
# make-mod.py generated code below v
#

