#########################################
# THIS FILE IS GENERATED BY make-mod.py #
# DO NOT EDIT IT BY HAND, EDIT EITHER   #
# make-mod.py OR make-mod.header.py     #
# IN THE CODEGEN DIRECTORY, AND RE-GEN  #
#########################################

import typing
from .line import Line

#
# This file has been generated from the Earendil IRC Protocol Specification,
# version 0.0
#

class Message:
    __slots__ = ['source']

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> Line:
        raise NotImplementedError('Message.to_line')

    def to_raw(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> bytes:
        return self.to_line().to_raw()

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> 'Message':
        global from_lines_by_verb
        try:
            return from_lines_by_verb[line.command](line, decode)
        except Exception:
            return Unknown.from_line(line, decode)

    @classmethod
    def from_raw(cls, line: bytes, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> 'Message':
        return cls.from_line(Line.from_raw(line), decode)

class Unknown(Message):
    __slots__ = ['command', 'arguments']

    def __init__(self, source: str, command: typing.Union[bytes, int], arguments: typing.List[bytes]) -> None:
        self.source = source
        self.command = command
        self.arguments = arguments

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode('utf-8')) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        return Line(source, self.command, self.arguments)

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode('utf-8')) -> Message:
        source = None
        if line.source is not None:
            try:
                source = decode(line.source)
            except Exception:
                pass
        return cls(source, line.command, line.arguments)

    def __repr__(self) -> str:
        return "Unknown(source={}, command={}, arguments={})".format(repr(self.source), repr(self.command), repr(self.arguments))

#
# make-mod.header.py above ^
# make-mod.py generated code below v
#



class MessageFactory:
    message_source = None # type: str
    def message(self, msg: Message) -> None:
        raise NotImplementedError("MessageFactory.message")

    def passwd(self, password: str) -> None:
        """
        ``PASS <password>``
        """

        self.message(Passwd(self.message_source, password=password))

    def nick(self, nickname: str) -> None:
        """
        ``NICK <nickname>``
        """

        self.message(Nick(self.message_source, nickname=nickname))

    def user(self, user: str, mode: int, realname: str) -> None:
        """
        ``USER <user> <int:mode> * <realname>``
        """

        self.message(User(self.message_source, user=user, mode=mode, realname=realname))

    def oper(self, name: str, password: str) -> None:
        """
        ``OPER <name> <password>``
        """

        self.message(Oper(self.message_source, name=name, password=password))

    def mode(self, name: str, mode: str) -> None:
        """
        ``MODE <name> <mode>``

        FIXME multiples.
        """

        self.message(Mode(self.message_source, name=name, mode=mode))

    def service(self, nickname: str, distribution: str, type: int, info: str) -> None:
        """
        ``SERVICE <nickname> * <distribution> <int:type> 0 <info>``
        """

        self.message(Service(self.message_source, nickname=nickname, distribution=distribution, type=type, info=info))

    def quit(self, message: str = None) -> None:
        """
        ``QUIT [message]``
        """

        self.message(Quit(self.message_source, message=message))

    def s_quit(self, server: str, comment: str) -> None:
        """
        ``SQUIT <server> <comment>``
        """

        self.message(SQuit(self.message_source, server=server, comment=comment))

    def channel_join(self, channels: typing.List[str], keys: typing.List[str] = None) -> None:
        """
        ``JOIN <channels,> [keys,]``
        """

        self.message(ChannelJoin(self.message_source, channels=channels, keys=keys))

    def channel_part(self, channels: typing.List[str], message: str = None) -> None:
        """
        ``PART <channels,> [message]``
        """

        self.message(ChannelPart(self.message_source, channels=channels, message=message))

    def topic(self, channel: str, topic: str = None) -> None:
        """
        ``TOPIC <channel> [topic]``
        """

        self.message(Topic(self.message_source, channel=channel, topic=topic))

    def names(self, channels: typing.List[str] = None, target: str = None) -> None:
        """
        ``NAMES [channels,] [target]``
        """

        self.message(Names(self.message_source, channels=channels, target=target))

    def list(self, channels: typing.List[str] = None, target: str = None) -> None:
        """
        ``LIST [channels,] [target]``
        """

        self.message(List(self.message_source, channels=channels, target=target))

    def invite(self, nickname: str, channel: str) -> None:
        """
        ``INVITE <nickname> <channel>``
        """

        self.message(Invite(self.message_source, nickname=nickname, channel=channel))

    def kick(self, channels: typing.List[str], users: typing.List[str], comment: str = None) -> None:
        """
        ``KICK <channels,> <users,> [comment]``
        """

        self.message(Kick(self.message_source, channels=channels, users=users, comment=comment))

    def privmsg(self, target: str, message: str) -> None:
        """
        ``PRIVMSG <target> <message>``
        """

        self.message(Privmsg(self.message_source, target=target, message=message))

    def notice(self, target: str, message: str) -> None:
        """
        ``NOTICE <target> <message>``
        """

        self.message(Notice(self.message_source, target=target, message=message))

    def motd(self, target: str = None) -> None:
        """
        ``MOTD [target]``
        """

        self.message(Motd(self.message_source, target=target))

    def lusers(self, mask: str = None, target: str = None) -> None:
        """
        ``LUSERS [mask] [target]``
        """

        self.message(Lusers(self.message_source, mask=mask, target=target))

    def version(self, target: str = None) -> None:
        """
        ``VERSION [target]``
        """

        self.message(Version(self.message_source, target=target))

    def stats(self, query: str = None, target: str = None) -> None:
        """
        ``STATS [query] [target]``
        """

        self.message(Stats(self.message_source, query=query, target=target))

    def links(self, server: str = None, mask: str = None) -> None:
        """
        ``LINKS (server) (mask)``
        """

        self.message(Links(self.message_source, server=server, mask=mask))

    def time(self, target: str = None) -> None:
        """
        ``TIME [target]``
        """

        self.message(Time(self.message_source, target=target))

    def server_connect(self, target: str, port: int, remote: str = None) -> None:
        """
        ``CONNECT <target> <int:port> [remote]``
        """

        self.message(ServerConnect(self.message_source, target=target, port=port, remote=remote))

    def trace(self, target: str = None) -> None:
        """
        ``TRACE [target]``
        """

        self.message(Trace(self.message_source, target=target))

    def admin(self, target: str = None) -> None:
        """
        ``ADMIN [target]``
        """

        self.message(Admin(self.message_source, target=target))

    def info(self, target: str = None) -> None:
        """
        ``INFO [target]``
        """

        self.message(Info(self.message_source, target=target))

    def serv_list(self, mask: str = None, type: str = None) -> None:
        """
        ``SERVLIST [mask] [type]``
        """

        self.message(ServList(self.message_source, mask=mask, type=type))

    def s_query(self, servicename: str, text: str) -> None:
        """
        ``SQUERY <servicename> <text>``
        """

        self.message(SQuery(self.message_source, servicename=servicename, text=text))

    def who(self, mask: str = None, operators: bool = None) -> None:
        """
        ``WHO [mask] [flag(o):operators]``
        """

        self.message(Who(self.message_source, mask=mask, operators=operators))

    def who_is(self, masks: typing.List[str], target: str = None) -> None:
        """
        ``WHOIS [target] <masks,>``
        """

        self.message(WhoIs(self.message_source, target=target, masks=masks))

    def who_was(self, nicknames: typing.List[str], count: int = None, target: str = None) -> None:
        """
        ``WHOWAS <nicknames,> [int:count] [target]``
        """

        self.message(WhoWas(self.message_source, nicknames=nicknames, count=count, target=target))

    def kill(self, nickname: str, comment: str) -> None:
        """
        ``KILL <nickname> <comment>``
        """

        self.message(Kill(self.message_source, nickname=nickname, comment=comment))

    def ping(self, server1: str, server2: str = None) -> None:
        """
        ``PING <server1> [server2]``
        """

        self.message(Ping(self.message_source, server1=server1, server2=server2))

    def pong(self, server: str, server2: str = None) -> None:
        """
        ``PONG <server> [server2]``
        """

        self.message(Pong(self.message_source, server=server, server2=server2))

    def error(self, message: str) -> None:
        """
        ``ERROR <message>``
        """

        self.message(Error(self.message_source, message=message))

    def away(self, text: str = None) -> None:
        """
        ``AWAY [text]``
        """

        self.message(Away(self.message_source, text=text))

    def rehash(self) -> None:
        """
        ``REHASH``
        """

        self.message(Rehash(self.message_source))

    def die(self) -> None:
        """
        ``DIE``
        """

        self.message(Die(self.message_source))

    def restart(self) -> None:
        """
        ``RESTART``
        """

        self.message(Restart(self.message_source))

    def summon(self, user: str, target: str = None, channel: str = None) -> None:
        """
        ``SUMMON <user> [target] [channel]``
        """

        self.message(Summon(self.message_source, user=user, target=target, channel=channel))

    def users(self, target: str = None) -> None:
        """
        ``USERS [target]``
        """

        self.message(Users(self.message_source, target=target))

    def wall_ops(self, message: str) -> None:
        """
        ``WALLOPS <message>``
        """

        self.message(WallOps(self.message_source, message=message))

    def user_host(self, nickname: str) -> None:
        """
        ``USERHOST <nickname>``

        FIXME many nicknames.
        """

        self.message(UserHost(self.message_source, nickname=nickname))

    def is_on(self, nickname: str) -> None:
        """
        ``ISON <nickname>``

        FIXME many nicknames.
        """

        self.message(IsOn(self.message_source, nickname=nickname))

    def welcome(self, target: str, message: str) -> None:
        """
        ``001 <target> <message>``
        """

        self.message(Welcome(self.message_source, target=target, message=message))

    def your_host(self, target: str, message: str) -> None:
        """
        ``002 <target> <message>``
        """

        self.message(YourHost(self.message_source, target=target, message=message))

    def created(self, target: str, message: str) -> None:
        """
        ``003 <target> <message>``
        """

        self.message(Created(self.message_source, target=target, message=message))

    def my_info(self, target: str, message: str) -> None:
        """
        ``004 <target> <message>``
        """

        self.message(MyInfo(self.message_source, target=target, message=message))

    def bounce(self, target: str, message: str) -> None:
        """
        ``005 <target> <message>``
        """

        self.message(Bounce(self.message_source, target=target, message=message))

    def trace_link_reply(self, target: str, version: str, destination: str, next: str, protocol_version: str, link_uptime: str, back_send_q: str, up_send_q: str) -> None:
        """
        ``200 <target> Link <version> <destination> <next> <protocol-version> <link-uptime> <back-send-q> <up-send-q>``
        """

        self.message(TraceLinkReply(self.message_source, target=target, version=version, destination=destination, next=next, protocol_version=protocol_version, link_uptime=link_uptime, back_send_q=back_send_q, up_send_q=up_send_q))

    def trace_connecting(self, target: str, klass: str, server: str) -> None:
        """
        ``201 <target> Try. <class> <server>``
        """

        self.message(TraceConnecting(self.message_source, target=target, klass=klass, server=server))

    def trace_handshake(self, target: str, klass: str, server: str) -> None:
        """
        ``202 <target> H.S. <class> <server>``
        """

        self.message(TraceHandshake(self.message_source, target=target, klass=klass, server=server))

    def trace_unknown(self, target: str, klass: str, ip: str = None) -> None:
        """
        ``203 <target> ???? <class> [ip]``
        """

        self.message(TraceUnknown(self.message_source, target=target, klass=klass, ip=ip))

    def trace_operator(self, target: str, klass: str, nickname: str) -> None:
        """
        ``204 <target> Oper <class> <nickname>``
        """

        self.message(TraceOperator(self.message_source, target=target, klass=klass, nickname=nickname))

    def trace_user(self, target: str, klass: str, nickname: str) -> None:
        """
        ``205 <target> User <class> <nickname>``
        """

        self.message(TraceUser(self.message_source, target=target, klass=klass, nickname=nickname))

    def trace_server(self, target: str, klass: str, s: str, c: str, server: str, hostmask: str, protocol_version: str) -> None:
        """
        ``206 <target> Serv <class> <s> <c> <server> <hostmask> <protocol-version>``
        """

        self.message(TraceServer(self.message_source, target=target, klass=klass, s=s, c=c, server=server, hostmask=hostmask, protocol_version=protocol_version))

    def trace_service(self, target: str, klass: str, name: str, type: str, active_type: str) -> None:
        """
        ``207 <target> Service <class> <name> <type> <active-type>``
        """

        self.message(TraceService(self.message_source, target=target, klass=klass, name=name, type=type, active_type=active_type))

    def trace_newtype(self, target: str, newtype: str, name: str) -> None:
        """
        ``208 <target> <newtype> 0 <name>``
        """

        self.message(TraceNewtype(self.message_source, target=target, newtype=newtype, name=name))

    def trace_class(self, target: str, klass: str, count: int) -> None:
        """
        ``209 <target> Class <class> <int:count>``
        """

        self.message(TraceClass(self.message_source, target=target, klass=klass, count=count))

    def stats_link_info(self, target: str, name: str, sendq: str, sent_messages: int, sent_kbytes: int, recv_messages: int, recv_kbytes: int, uptime: int) -> None:
        """
        ``211 <target> <name> <sendq> <int:sent-messages> <int:sent-kbytes> <int:recv-messages> <int:recv-kbytes> <int:uptime>``
        """

        self.message(StatsLinkInfo(self.message_source, target=target, name=name, sendq=sendq, sent_messages=sent_messages, sent_kbytes=sent_kbytes, recv_messages=recv_messages, recv_kbytes=recv_kbytes, uptime=uptime))

    def stats_commands(self, target: str, command: str, count: int, bytecount: int, remote_count: int) -> None:
        """
        ``212 <target> <command> <int:count> <int:bytes> <int:remote-count>``
        """

        self.message(StatsCommands(self.message_source, target=target, command=command, count=count, bytecount=bytecount, remote_count=remote_count))

    def stats_end(self, target: str, letter: str) -> None:
        """
        ``219 <target> <letter> :End of STATS report``
        """

        self.message(StatsEnd(self.message_source, target=target, letter=letter))

    def user_mode_is(self, target: str, mode: str) -> None:
        """
        ``221 <target> <mode>``
        """

        self.message(UserModeIs(self.message_source, target=target, mode=mode))

    def serv_list_reply(self, target: str, name: str, server: str, mask: str, type: str, hopcount: int, info: str) -> None:
        """
        ``234 <target> <name> <server> <mask> <type> <int:hopcount> <info>``
        """

        self.message(ServListReply(self.message_source, target=target, name=name, server=server, mask=mask, type=type, hopcount=hopcount, info=info))

    def serv_list_end(self, target: str, mask: str, type: str) -> None:
        """
        ``235 <target> <mask> <type> :End of service listing``
        """

        self.message(ServListEnd(self.message_source, target=target, mask=mask, type=type))

    def stats_uptime(self, target: str, message: str) -> None:
        """
        ``242 <target> <message>``
        """

        self.message(StatsUptime(self.message_source, target=target, message=message))

    def stats_oline(self, target: str, hostmask: str, name: str) -> None:
        """
        ``243 <target> O <hostmask> * <name>``
        """

        self.message(StatsOline(self.message_source, target=target, hostmask=hostmask, name=name))

    def luser_client(self, target: str, message: str) -> None:
        """
        ``251 <target> <message>``
        """

        self.message(LuserClient(self.message_source, target=target, message=message))

    def luser_op(self, target: str, count: int) -> None:
        """
        ``252 <target> <int:count> :operator(s) online``
        """

        self.message(LuserOp(self.message_source, target=target, count=count))

    def luser_unknown(self, target: str, count: int) -> None:
        """
        ``253 <target> <int:count> :unknown connection(s)``
        """

        self.message(LuserUnknown(self.message_source, target=target, count=count))

    def luser_channels(self, target: str, count: int) -> None:
        """
        ``254 <target> <int:count> :channels formed``
        """

        self.message(LuserChannels(self.message_source, target=target, count=count))

    def luser_me(self, target: str, message: str) -> None:
        """
        ``255 <target> <message>``
        """

        self.message(LuserMe(self.message_source, target=target, message=message))

    def admin_me(self, target: str, server: str) -> None:
        """
        ``256 <target> <server> :Administrative info``
        """

        self.message(AdminMe(self.message_source, target=target, server=server))

    def admin_loc1(self, target: str, message: str) -> None:
        """
        ``257 <target> <message>``
        """

        self.message(AdminLoc1(self.message_source, target=target, message=message))

    def admin_loc2(self, target: str, message: str) -> None:
        """
        ``258 <target> <message>``
        """

        self.message(AdminLoc2(self.message_source, target=target, message=message))

    def admin_email(self, target: str, email: str) -> None:
        """
        ``259 <target> <email>``
        """

        self.message(AdminEmail(self.message_source, target=target, email=email))

    def trace_log(self, target: str, logfile: str, debug_level: str) -> None:
        """
        ``261 <target> File <logfile> <debug-level>``
        """

        self.message(TraceLog(self.message_source, target=target, logfile=logfile, debug_level=debug_level))

    def trace_end(self, target: str, server: str, version: str) -> None:
        """
        ``262 <target> <server> <version> :End of TRACE``
        """

        self.message(TraceEnd(self.message_source, target=target, server=server, version=version))

    def try_again(self, target: str, command: str) -> None:
        """
        ``263 <target> <command> :Please wait a while and try again.``
        """

        self.message(TryAgain(self.message_source, target=target, command=command))

    def away_reply(self, target: str, nickname: str, message: str) -> None:
        """
        ``301 <target> <nickname> <message>``
        """

        self.message(AwayReply(self.message_source, target=target, nickname=nickname, message=message))

    def user_host_reply(self, target: str, message: str) -> None:
        """
        ``302 <target> <message>``

        FIXME parse data!
        """

        self.message(UserHostReply(self.message_source, target=target, message=message))

    def is_on_reply(self, target: str, message: str) -> None:
        """
        ``303 <target> <message>``

        FIXME parse data!
        """

        self.message(IsOnReply(self.message_source, target=target, message=message))

    def unaway_reply(self, target: str) -> None:
        """
        ``305 <target> :You are no longer marked as being away``
        """

        self.message(UnawayReply(self.message_source, target=target))

    def now_away_reply(self, target: str) -> None:
        """
        ``306 <target> :You have been marked as being away``
        """

        self.message(NowAwayReply(self.message_source, target=target))

    def who_is_user(self, target: str, nickname: str, user: str, host: str, realname: str) -> None:
        """
        ``311 <target> <nickname> <user> <host> * <realname>``
        """

        self.message(WhoIsUser(self.message_source, target=target, nickname=nickname, user=user, host=host, realname=realname))

    def who_is_server(self, target: str, nickname: str, server: str, info: str) -> None:
        """
        ``312 <target> <nickname> <server> <info>``
        """

        self.message(WhoIsServer(self.message_source, target=target, nickname=nickname, server=server, info=info))

    def who_is_operator(self, target: str, nickname: str) -> None:
        """
        ``313 <target> <nickname> :is an IRC operator``
        """

        self.message(WhoIsOperator(self.message_source, target=target, nickname=nickname))

    def who_was_user(self, target: str, nickname: str, user: str, host: str, realname: str) -> None:
        """
        ``314 <target> <nickname> <user> <host> * <realname>``
        """

        self.message(WhoWasUser(self.message_source, target=target, nickname=nickname, user=user, host=host, realname=realname))

    def who_end(self, target: str, name: str) -> None:
        """
        ``315 <target> <name> :End of WHO list``
        """

        self.message(WhoEnd(self.message_source, target=target, name=name))

    def who_is_idle(self, target: str, nickname: str, time: int) -> None:
        """
        ``317 <target> <nickname> <int:time> :seconds idle``
        """

        self.message(WhoIsIdle(self.message_source, target=target, nickname=nickname, time=time))

    def who_is_end(self, target: str, nickname: str) -> None:
        """
        ``318 <target> <nickname> :End of WHOIS list``
        """

        self.message(WhoIsEnd(self.message_source, target=target, nickname=nickname))

    def who_is_channels(self, target: str, nickname: str, channels: str) -> None:
        """
        ``319 <target> <nickname> <channels>``
        """

        self.message(WhoIsChannels(self.message_source, target=target, nickname=nickname, channels=channels))

    def list_reply(self, target: str, channel: str, visible: int, topic: str) -> None:
        """
        ``322 <target> <channel> <int:visible> <topic>``
        """

        self.message(ListReply(self.message_source, target=target, channel=channel, visible=visible, topic=topic))

    def list_end(self, target: str) -> None:
        """
        ``323 <target> :End of LIST``
        """

        self.message(ListEnd(self.message_source, target=target))

    def channel_mode_is(self, target: str, channel: str, mode: str, params: str) -> None:
        """
        ``324 <target> <channel> <mode> <params>``
        """

        self.message(ChannelModeIs(self.message_source, target=target, channel=channel, mode=mode, params=params))

    def uniq_op_is(self, target: str, channel: str, nickname: str) -> None:
        """
        ``325 <target> <channel> <nickname>``
        """

        self.message(UniqOpIs(self.message_source, target=target, channel=channel, nickname=nickname))

    def no_topic_reply(self, target: str, channel: str) -> None:
        """
        ``331 <target> <channel> :No topic is set``
        """

        self.message(NoTopicReply(self.message_source, target=target, channel=channel))

    def topic_reply(self, target: str, channel: str, topic: str) -> None:
        """
        ``332 <target> <channel> <topic>``
        """

        self.message(TopicReply(self.message_source, target=target, channel=channel, topic=topic))

    def inviting(self, target: str, channel: str, nick: str) -> None:
        """
        ``341 <target> <channel> <nick>``
        """

        self.message(Inviting(self.message_source, target=target, channel=channel, nick=nick))

    def summoning(self, target: str, user: str) -> None:
        """
        ``342 <target> <user> :Summoning user to IRC``
        """

        self.message(Summoning(self.message_source, target=target, user=user))

    def invite_list(self, target: str, channel: str, mask: str) -> None:
        """
        ``346 <target> <channel> <mask>``
        """

        self.message(InviteList(self.message_source, target=target, channel=channel, mask=mask))

    def invite_list_end(self, target: str, channel: str) -> None:
        """
        ``347 <target> <channel> :End of channel invite list``
        """

        self.message(InviteListEnd(self.message_source, target=target, channel=channel))

    def except_list(self, target: str, channel: str, mask: str) -> None:
        """
        ``348 <target> <channel> <mask>``
        """

        self.message(ExceptList(self.message_source, target=target, channel=channel, mask=mask))

    def except_list_end(self, target: str, channel: str) -> None:
        """
        ``349 <target> <channel> :End of channel exception list``
        """

        self.message(ExceptListEnd(self.message_source, target=target, channel=channel))

    def version_reply(self, target: str, version: str, server: str, comments: str) -> None:
        """
        ``351 <target> <version> <server> <comments>``
        """

        self.message(VersionReply(self.message_source, target=target, version=version, server=server, comments=comments))

    def who_reply(self, target: str, channel: str, user: str, host: str, server: str, nickname: str, props: str, realname: str) -> None:
        """
        ``352 <target> <channel> <user> <host> <server> <nickname> <props> <realname>``
        """

        self.message(WhoReply(self.message_source, target=target, channel=channel, user=user, host=host, server=server, nickname=nickname, props=props, realname=realname))

    def names_reply(self, target: str, mode: str, channel: str, nicknames: typing.List[str]) -> None:
        """
        ``353 <target> <mode> <channel> <nicknames_>``
        """

        self.message(NamesReply(self.message_source, target=target, mode=mode, channel=channel, nicknames=nicknames))

    def links_reply(self, target: str, mask: str, server: str, info: str) -> None:
        """
        ``364 <target> <mask> <server> <info>``
        """

        self.message(LinksReply(self.message_source, target=target, mask=mask, server=server, info=info))

    def links_end(self, target: str, mask: str) -> None:
        """
        ``365 <target> <mask> :End of LINKS list``
        """

        self.message(LinksEnd(self.message_source, target=target, mask=mask))

    def names_end(self, target: str, channel: str) -> None:
        """
        ``366 <target> <channel> :End of NAMES list``
        """

        self.message(NamesEnd(self.message_source, target=target, channel=channel))

    def ban_list(self, target: str, channel: str, mask: str) -> None:
        """
        ``367 <target> <channel> <mask>``
        """

        self.message(BanList(self.message_source, target=target, channel=channel, mask=mask))

    def ban_list_end(self, target: str, channel: str) -> None:
        """
        ``368 <target> <channel> :End of channel ban list``
        """

        self.message(BanListEnd(self.message_source, target=target, channel=channel))

    def who_was_end(self, target: str, nickname: str) -> None:
        """
        ``369 <target> <nickname> :End of WHOWAS``
        """

        self.message(WhoWasEnd(self.message_source, target=target, nickname=nickname))

    def info_reply(self, target: str, info: str) -> None:
        """
        ``371 <target> <info>``
        """

        self.message(InfoReply(self.message_source, target=target, info=info))

    def motd_text(self, target: str, message: str) -> None:
        """
        ``372 <target> <message>``
        """

        self.message(MotdText(self.message_source, target=target, message=message))

    def info_end(self, target: str) -> None:
        """
        ``374 <target> :End of INFO list``
        """

        self.message(InfoEnd(self.message_source, target=target))

    def motd_start(self, target: str, message: str) -> None:
        """
        ``375 <target> <message>``
        """

        self.message(MotdStart(self.message_source, target=target, message=message))

    def motd_end(self, target: str) -> None:
        """
        ``376 <target> :End of MOTD command``
        """

        self.message(MotdEnd(self.message_source, target=target))

    def youre_oper(self, target: str) -> None:
        """
        ``381 <target> :You are now an IRC operator``
        """

        self.message(YoureOper(self.message_source, target=target))

    def rehashing(self, target: str, file: str) -> None:
        """
        ``382 <target> <file> Rehashing``
        """

        self.message(Rehashing(self.message_source, target=target, file=file))

    def youre_service(self, target: str, message: str) -> None:
        """
        ``383 <target> <message>``
        """

        self.message(YoureService(self.message_source, target=target, message=message))

    def time_reply(self, target: str, server: str, time: str) -> None:
        """
        ``391 <target> <server> <time>``
        """

        self.message(TimeReply(self.message_source, target=target, server=server, time=time))

    def users_start(self, target: str) -> None:
        """
        ``392 <target> :UserID   Terminal  Host``
        """

        self.message(UsersStart(self.message_source, target=target))

    def users_reply(self, target: str, message: str) -> None:
        """
        ``393 <target> <message>``
        """

        self.message(UsersReply(self.message_source, target=target, message=message))

    def users_end(self, target: str) -> None:
        """
        ``394 <target> :End of users``
        """

        self.message(UsersEnd(self.message_source, target=target))

    def no_users(self, target: str) -> None:
        """
        ``395 <target> :Nobody logged in``
        """

        self.message(NoUsers(self.message_source, target=target))

    def no_such_nick(self, target: str, nickname: str) -> None:
        """
        ``401 <target> <nickname> :No such nick/channel``
        """

        self.message(NoSuchNick(self.message_source, target=target, nickname=nickname))

    def no_such_server(self, target: str, server: str) -> None:
        """
        ``402 <target> <server> :No such server``
        """

        self.message(NoSuchServer(self.message_source, target=target, server=server))

    def no_such_channel(self, target: str, channel: str) -> None:
        """
        ``403 <target> <channel> :No such channel``
        """

        self.message(NoSuchChannel(self.message_source, target=target, channel=channel))

    def cant_send_to_chan(self, target: str, channel: str) -> None:
        """
        ``404 <target> <channel> :Cannot send to channel``
        """

        self.message(CantSendToChan(self.message_source, target=target, channel=channel))

    def too_many_channels(self, target: str, channel: str) -> None:
        """
        ``405 <target> <channel> :You have joined too many channels``
        """

        self.message(TooManyChannels(self.message_source, target=target, channel=channel))

    def was_no_such_nick(self, target: str, nickname: str) -> None:
        """
        ``406 <target> <nickname> :There was no such nickname``
        """

        self.message(WasNoSuchNick(self.message_source, target=target, nickname=nickname))

    def too_many_targets(self, target: str, orig_target: str, message: str) -> None:
        """
        ``407 <target> <orig-target> <message>``
        """

        self.message(TooManyTargets(self.message_source, target=target, orig_target=orig_target, message=message))

    def no_such_service(self, target: str, name: str) -> None:
        """
        ``408 <target> <name> :No such service``
        """

        self.message(NoSuchService(self.message_source, target=target, name=name))

    def no_origin(self, target: str) -> None:
        """
        ``409 <target> :No origin specified``
        """

        self.message(NoOrigin(self.message_source, target=target))

    def no_recipient(self, target: str) -> None:
        """
        ``411 <target> :No recipient given``
        """

        self.message(NoRecipient(self.message_source, target=target))

    def no_text_to_send(self, target: str) -> None:
        """
        ``412 <target> :No text to send``
        """

        self.message(NoTextToSend(self.message_source, target=target))

    def no_top_level(self, target: str, mask: str) -> None:
        """
        ``413 <target> <mask> :No toplevel domain specified``
        """

        self.message(NoTopLevel(self.message_source, target=target, mask=mask))

    def wild_top_level(self, target: str, mask: str) -> None:
        """
        ``414 <target> <mask> :Wildcard in toplevel domain``
        """

        self.message(WildTopLevel(self.message_source, target=target, mask=mask))

    def bad_mask(self, target: str, mask: str) -> None:
        """
        ``415 <target> <mask> :Bad Server/host mask``
        """

        self.message(BadMask(self.message_source, target=target, mask=mask))

    def unknown_command(self, target: str, command: str) -> None:
        """
        ``421 <target> <command> :Unknown command``
        """

        self.message(UnknownCommand(self.message_source, target=target, command=command))

    def no_motd(self, target: str) -> None:
        """
        ``422 <target> :MOTD File is missing``
        """

        self.message(NoMotd(self.message_source, target=target))

    def no_admin_info(self, target: str, server: str) -> None:
        """
        ``423 <target> <server> :No administrative info available``
        """

        self.message(NoAdminInfo(self.message_source, target=target, server=server))

    def file_error(self, target: str, message: str) -> None:
        """
        ``424 <target> <message>``
        """

        self.message(FileError(self.message_source, target=target, message=message))

    def no_nickname_given(self, target: str) -> None:
        """
        ``431 <target> :No nickname given``
        """

        self.message(NoNicknameGiven(self.message_source, target=target))

    def erroneus_nickname(self, target: str, nickname: str) -> None:
        """
        ``432 <target> <nickname> :Erroneous nickname``
        """

        self.message(ErroneusNickname(self.message_source, target=target, nickname=nickname))

    def nickname_in_use(self, target: str, nickname: str) -> None:
        """
        ``433 <target> <nickname> :Nickname is already in use``
        """

        self.message(NicknameInUse(self.message_source, target=target, nickname=nickname))

    def nick_collision(self, target: str, nickname: str, message: str) -> None:
        """
        ``436 <target> <nickname> <message>``
        """

        self.message(NickCollision(self.message_source, target=target, nickname=nickname, message=message))

    def unavail_resource(self, target: str, name: str) -> None:
        """
        ``437 <target> <name> :Nick/channel is temporarily unavailable``
        """

        self.message(UnavailResource(self.message_source, target=target, name=name))

    def user_not_in_channel(self, target: str, nickname: str, channel: str) -> None:
        """
        ``441 <target> <nickname> <channel> :They aren't on that channel``
        """

        self.message(UserNotInChannel(self.message_source, target=target, nickname=nickname, channel=channel))

    def not_on_channel(self, target: str, channel: str) -> None:
        """
        ``442 <target> <channel> :You're not on that channel``
        """

        self.message(NotOnChannel(self.message_source, target=target, channel=channel))

    def user_on_channel(self, target: str, user: str, channel: str) -> None:
        """
        ``443 <target> <user> <channel> :is already on channel``
        """

        self.message(UserOnChannel(self.message_source, target=target, user=user, channel=channel))

    def no_login(self, target: str, user: str) -> None:
        """
        ``444 <target> <user> :User not logged in``
        """

        self.message(NoLogin(self.message_source, target=target, user=user))

    def summon_disabled(self, target: str) -> None:
        """
        ``445 <target> :SUMMON has been disabled``
        """

        self.message(SummonDisabled(self.message_source, target=target))

    def users_disabled(self, target: str) -> None:
        """
        ``446 <target> :USERS has been disabled``
        """

        self.message(UsersDisabled(self.message_source, target=target))

    def not_registered(self, target: str) -> None:
        """
        ``451 <target> :You have not registered``
        """

        self.message(NotRegistered(self.message_source, target=target))

    def need_more_params(self, target: str, command: str) -> None:
        """
        ``461 <target> <command> :Not enough parameters``
        """

        self.message(NeedMoreParams(self.message_source, target=target, command=command))

    def already_registered(self, target: str) -> None:
        """
        ``462 <target> :Unauthorized command (already registered)``
        """

        self.message(AlreadyRegistered(self.message_source, target=target))

    def no_perm_for_host(self, target: str) -> None:
        """
        ``463 <target> :Your host isn't among the privileged``
        """

        self.message(NoPermForHost(self.message_source, target=target))

    def password_mismatch(self, target: str) -> None:
        """
        ``464 <target> :Password incorrect``
        """

        self.message(PasswordMismatch(self.message_source, target=target))

    def youre_banned_creep(self, target: str) -> None:
        """
        ``465 <target> :You are banned from this server``
        """

        self.message(YoureBannedCreep(self.message_source, target=target))

    def you_will_be_banned(self, target: str) -> None:
        """
        ``466 <target>``
        """

        self.message(YouWillBeBanned(self.message_source, target=target))

    def key_set(self, target: str, channel: str) -> None:
        """
        ``467 <target> <channel> :Channel key already set``
        """

        self.message(KeySet(self.message_source, target=target, channel=channel))

    def channel_is_full(self, target: str, channel: str) -> None:
        """
        ``471 <target> <channel> :Cannot join channel (+l)``
        """

        self.message(ChannelIsFull(self.message_source, target=target, channel=channel))

    def unknown_mode(self, target: str, char: str) -> None:
        """
        ``472 <target> <char> :is unknown mode char to me``
        """

        self.message(UnknownMode(self.message_source, target=target, char=char))

    def invite_only_chan(self, target: str, channel: str) -> None:
        """
        ``473 <target> <channel> :Cannot join channel (+i)``
        """

        self.message(InviteOnlyChan(self.message_source, target=target, channel=channel))

    def banned_from_chan(self, target: str, channel: str) -> None:
        """
        ``474 <target> <channel> :Cannot join channel (+b)``
        """

        self.message(BannedFromChan(self.message_source, target=target, channel=channel))

    def bad_channel_key(self, target: str, channel: str) -> None:
        """
        ``475 <target> <channel> :Cannot join channel (+k)``
        """

        self.message(BadChannelKey(self.message_source, target=target, channel=channel))

    def bad_chan_mask(self, target: str, channel: str) -> None:
        """
        ``476 <target> <channel> :Bad Channel Mask``
        """

        self.message(BadChanMask(self.message_source, target=target, channel=channel))

    def no_chan_modes(self, target: str, channel: str) -> None:
        """
        ``477 <target> <channel> :Channel doesn't support modes``
        """

        self.message(NoChanModes(self.message_source, target=target, channel=channel))

    def ban_list_full(self, target: str, channel: str, char: str) -> None:
        """
        ``478 <target> <channel> <char> :Channel list is full``
        """

        self.message(BanListFull(self.message_source, target=target, channel=channel, char=char))

    def no_privileges(self, target: str) -> None:
        """
        ``481 <target> :Permission Denied- You're not an IRC operator``
        """

        self.message(NoPrivileges(self.message_source, target=target))

    def chan_op_privs_needed(self, target: str, channel: str) -> None:
        """
        ``482 <target> <channel> :You're not channel operator``
        """

        self.message(ChanOpPrivsNeeded(self.message_source, target=target, channel=channel))

    def cant_kill_server(self, target: str) -> None:
        """
        ``483 <target> :You can't kill a server!``
        """

        self.message(CantKillServer(self.message_source, target=target))

    def restricted(self, target: str) -> None:
        """
        ``484 <target> :Your connection is restricted!``
        """

        self.message(Restricted(self.message_source, target=target))

    def uniq_op_privs_needed(self, target: str) -> None:
        """
        ``485 <target> :You're not the original channel operator``
        """

        self.message(UniqOpPrivsNeeded(self.message_source, target=target))

    def no_oper_host(self, target: str) -> None:
        """
        ``491 <target> :No O-lines for your host``
        """

        self.message(NoOperHost(self.message_source, target=target))

    def user_mode_unknown_flag(self, target: str) -> None:
        """
        ``501 <target> :Unknown MODE flag``
        """

        self.message(UserModeUnknownFlag(self.message_source, target=target))

    def users_dont_match(self, target: str) -> None:
        """
        ``502 <target> :Cannot change mode for other users``
        """

        self.message(UsersDontMatch(self.message_source, target=target))


class Passwd(Message):
    """
    ``PASS <password>``
    """

    __slots__ = ['password']

    def __init__(self, source: str, password: str) -> None:
        self.source = source
        self.password = password

    def __repr__(self) -> str:
        return 'Passwd(source={}, password={})'.format(repr(self.source), repr(self.password))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'PASS':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        password = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, password=password)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.password))
        return Line(source, b'PASS', arguments)


class Nick(Message):
    """
    ``NICK <nickname>``
    """

    __slots__ = ['nickname']

    def __init__(self, source: str, nickname: str) -> None:
        self.source = source
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'Nick(source={}, nickname={})'.format(repr(self.source), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'NICK':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        nickname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.nickname))
        return Line(source, b'NICK', arguments)


class User(Message):
    """
    ``USER <user> <int:mode> * <realname>``
    """

    __slots__ = ['user', 'mode', 'realname']

    def __init__(self, source: str, user: str, mode: int, realname: str) -> None:
        self.source = source
        self.user = user
        self.mode = mode
        self.realname = realname

    def __repr__(self) -> str:
        return 'User(source={}, user={}, mode={}, realname={})'.format(repr(self.source), repr(self.user), repr(self.mode), repr(self.realname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'USER':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        user = decode(line.arguments[i])
        i += 1
        mode = int(line.arguments[i])
        i += 1
        # line.arguments[i]: '*'
        i += 1
        realname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, user=user, mode=mode, realname=realname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.user))
        arguments.append(encode(str(self.mode)))
        arguments.append(b'*')
        arguments.append(encode(self.realname))
        return Line(source, b'USER', arguments)


class Oper(Message):
    """
    ``OPER <name> <password>``
    """

    __slots__ = ['name', 'password']

    def __init__(self, source: str, name: str, password: str) -> None:
        self.source = source
        self.name = name
        self.password = password

    def __repr__(self) -> str:
        return 'Oper(source={}, name={}, password={})'.format(repr(self.source), repr(self.name), repr(self.password))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'OPER':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        name = decode(line.arguments[i])
        i += 1
        password = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, name=name, password=password)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.name))
        arguments.append(encode(self.password))
        return Line(source, b'OPER', arguments)


class Mode(Message):
    """
    ``MODE <name> <mode>``

    FIXME multiples.
    """

    __slots__ = ['name', 'mode']

    def __init__(self, source: str, name: str, mode: str) -> None:
        self.source = source
        self.name = name
        self.mode = mode

    def __repr__(self) -> str:
        return 'Mode(source={}, name={}, mode={})'.format(repr(self.source), repr(self.name), repr(self.mode))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'MODE':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        name = decode(line.arguments[i])
        i += 1
        mode = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, name=name, mode=mode)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.name))
        arguments.append(encode(self.mode))
        return Line(source, b'MODE', arguments)


class Service(Message):
    """
    ``SERVICE <nickname> * <distribution> <int:type> 0 <info>``
    """

    __slots__ = ['nickname', 'distribution', 'type', 'info']

    def __init__(self, source: str, nickname: str, distribution: str, type: int, info: str) -> None:
        self.source = source
        self.nickname = nickname
        self.distribution = distribution
        self.type = type
        self.info = info

    def __repr__(self) -> str:
        return 'Service(source={}, nickname={}, distribution={}, type={}, info={})'.format(repr(self.source), repr(self.nickname), repr(self.distribution), repr(self.type), repr(self.info))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'SERVICE':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 6):
            raise ValueError("wrong number of arguments")
        i = 0
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: '*'
        i += 1
        distribution = decode(line.arguments[i])
        i += 1
        type = int(line.arguments[i])
        i += 1
        # line.arguments[i]: '0'
        i += 1
        info = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, nickname=nickname, distribution=distribution, type=type, info=info)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.nickname))
        arguments.append(b'*')
        arguments.append(encode(self.distribution))
        arguments.append(encode(str(self.type)))
        arguments.append(b'0')
        arguments.append(encode(self.info))
        return Line(source, b'SERVICE', arguments)


class Quit(Message):
    """
    ``QUIT [message]``
    """

    __slots__ = ['message']

    def __init__(self, source: str, message: str = None) -> None:
        self.source = source
        self.message = message

    def __repr__(self) -> str:
        return 'Quit(source={}, message={})'.format(repr(self.source), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'QUIT':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            message = decode(line.arguments[i])
            i += 1
        else:
            message = None
        assert i == len(line.arguments)
        return cls(source=source, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.message is not None:
            arguments.append(encode(self.message))
        return Line(source, b'QUIT', arguments)


class SQuit(Message):
    """
    ``SQUIT <server> <comment>``
    """

    __slots__ = ['server', 'comment']

    def __init__(self, source: str, server: str, comment: str) -> None:
        self.source = source
        self.server = server
        self.comment = comment

    def __repr__(self) -> str:
        return 'SQuit(source={}, server={}, comment={})'.format(repr(self.source), repr(self.server), repr(self.comment))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'SQUIT':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        server = decode(line.arguments[i])
        i += 1
        comment = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, server=server, comment=comment)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.server))
        arguments.append(encode(self.comment))
        return Line(source, b'SQUIT', arguments)


class ChannelJoin(Message):
    """
    ``JOIN <channels,> [keys,]``
    """

    __slots__ = ['channels', 'keys']

    def __init__(self, source: str, channels: typing.List[str], keys: typing.List[str] = None) -> None:
        self.source = source
        self.channels = channels
        self.keys = keys

    def __repr__(self) -> str:
        return 'ChannelJoin(source={}, channels={}, keys={})'.format(repr(self.source), repr(self.channels), repr(self.keys))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'JOIN':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        channels = [decode(x) for x in line.arguments[i].split(b",")]
        i += 1
        if len(line.arguments) > 1:
            keys = [decode(x) for x in line.arguments[i].split(b",")]
            i += 1
        else:
            keys = None
        assert i == len(line.arguments)
        return cls(source=source, channels=channels, keys=keys)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(b",".join(encode(x) for x in self.channels))
        if self.keys is not None:
            arguments.append(b",".join(encode(x) for x in self.keys))
        return Line(source, b'JOIN', arguments)


class ChannelPart(Message):
    """
    ``PART <channels,> [message]``
    """

    __slots__ = ['channels', 'message']

    def __init__(self, source: str, channels: typing.List[str], message: str = None) -> None:
        self.source = source
        self.channels = channels
        self.message = message

    def __repr__(self) -> str:
        return 'ChannelPart(source={}, channels={}, message={})'.format(repr(self.source), repr(self.channels), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'PART':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        channels = [decode(x) for x in line.arguments[i].split(b",")]
        i += 1
        if len(line.arguments) > 1:
            message = decode(line.arguments[i])
            i += 1
        else:
            message = None
        assert i == len(line.arguments)
        return cls(source=source, channels=channels, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(b",".join(encode(x) for x in self.channels))
        if self.message is not None:
            arguments.append(encode(self.message))
        return Line(source, b'PART', arguments)


class Topic(Message):
    """
    ``TOPIC <channel> [topic]``
    """

    __slots__ = ['channel', 'topic']

    def __init__(self, source: str, channel: str, topic: str = None) -> None:
        self.source = source
        self.channel = channel
        self.topic = topic

    def __repr__(self) -> str:
        return 'Topic(source={}, channel={}, topic={})'.format(repr(self.source), repr(self.channel), repr(self.topic))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'TOPIC':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        channel = decode(line.arguments[i])
        i += 1
        if len(line.arguments) > 1:
            topic = decode(line.arguments[i])
            i += 1
        else:
            topic = None
        assert i == len(line.arguments)
        return cls(source=source, channel=channel, topic=topic)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.channel))
        if self.topic is not None:
            arguments.append(encode(self.topic))
        return Line(source, b'TOPIC', arguments)


class Names(Message):
    """
    ``NAMES [channels,] [target]``
    """

    __slots__ = ['channels', 'target']

    def __init__(self, source: str, channels: typing.List[str] = None, target: str = None) -> None:
        self.source = source
        self.channels = channels
        self.target = target

    def __repr__(self) -> str:
        return 'Names(source={}, channels={}, target={})'.format(repr(self.source), repr(self.channels), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'NAMES':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            channels = [decode(x) for x in line.arguments[i].split(b",")]
            i += 1
        else:
            channels = None
        if len(line.arguments) > 1:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, channels=channels, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.channels is not None:
            arguments.append(b",".join(encode(x) for x in self.channels))
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'NAMES', arguments)


class List(Message):
    """
    ``LIST [channels,] [target]``
    """

    __slots__ = ['channels', 'target']

    def __init__(self, source: str, channels: typing.List[str] = None, target: str = None) -> None:
        self.source = source
        self.channels = channels
        self.target = target

    def __repr__(self) -> str:
        return 'List(source={}, channels={}, target={})'.format(repr(self.source), repr(self.channels), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'LIST':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            channels = [decode(x) for x in line.arguments[i].split(b",")]
            i += 1
        else:
            channels = None
        if len(line.arguments) > 1:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, channels=channels, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.channels is not None:
            arguments.append(b",".join(encode(x) for x in self.channels))
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'LIST', arguments)


class Invite(Message):
    """
    ``INVITE <nickname> <channel>``
    """

    __slots__ = ['nickname', 'channel']

    def __init__(self, source: str, nickname: str, channel: str) -> None:
        self.source = source
        self.nickname = nickname
        self.channel = channel

    def __repr__(self) -> str:
        return 'Invite(source={}, nickname={}, channel={})'.format(repr(self.source), repr(self.nickname), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'INVITE':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        nickname = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, nickname=nickname, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.channel))
        return Line(source, b'INVITE', arguments)


class Kick(Message):
    """
    ``KICK <channels,> <users,> [comment]``
    """

    __slots__ = ['channels', 'users', 'comment']

    def __init__(self, source: str, channels: typing.List[str], users: typing.List[str], comment: str = None) -> None:
        self.source = source
        self.channels = channels
        self.users = users
        self.comment = comment

    def __repr__(self) -> str:
        return 'Kick(source={}, channels={}, users={}, comment={})'.format(repr(self.source), repr(self.channels), repr(self.users), repr(self.comment))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'KICK':
            raise ValueError("incorrect verb")
        if not (2 <= len(line.arguments) <= 3):
            raise ValueError("wrong number of arguments")
        i = 0
        channels = [decode(x) for x in line.arguments[i].split(b",")]
        i += 1
        users = [decode(x) for x in line.arguments[i].split(b",")]
        i += 1
        if len(line.arguments) > 2:
            comment = decode(line.arguments[i])
            i += 1
        else:
            comment = None
        assert i == len(line.arguments)
        return cls(source=source, channels=channels, users=users, comment=comment)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(b",".join(encode(x) for x in self.channels))
        arguments.append(b",".join(encode(x) for x in self.users))
        if self.comment is not None:
            arguments.append(encode(self.comment))
        return Line(source, b'KICK', arguments)


class Privmsg(Message):
    """
    ``PRIVMSG <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'Privmsg(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'PRIVMSG':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b'PRIVMSG', arguments)


class Notice(Message):
    """
    ``NOTICE <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'Notice(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'NOTICE':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b'NOTICE', arguments)


class Motd(Message):
    """
    ``MOTD [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Motd(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'MOTD':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'MOTD', arguments)


class Lusers(Message):
    """
    ``LUSERS [mask] [target]``
    """

    __slots__ = ['mask', 'target']

    def __init__(self, source: str, mask: str = None, target: str = None) -> None:
        self.source = source
        self.mask = mask
        self.target = target

    def __repr__(self) -> str:
        return 'Lusers(source={}, mask={}, target={})'.format(repr(self.source), repr(self.mask), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'LUSERS':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            mask = decode(line.arguments[i])
            i += 1
        else:
            mask = None
        if len(line.arguments) > 1:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, mask=mask, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.mask is not None:
            arguments.append(encode(self.mask))
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'LUSERS', arguments)


class Version(Message):
    """
    ``VERSION [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Version(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'VERSION':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'VERSION', arguments)


class Stats(Message):
    """
    ``STATS [query] [target]``
    """

    __slots__ = ['query', 'target']

    def __init__(self, source: str, query: str = None, target: str = None) -> None:
        self.source = source
        self.query = query
        self.target = target

    def __repr__(self) -> str:
        return 'Stats(source={}, query={}, target={})'.format(repr(self.source), repr(self.query), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'STATS':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            query = decode(line.arguments[i])
            i += 1
        else:
            query = None
        if len(line.arguments) > 1:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, query=query, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.query is not None:
            arguments.append(encode(self.query))
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'STATS', arguments)


class Links(Message):
    """
    ``LINKS (server) (mask)``
    """

    __slots__ = ['server', 'mask']

    def __init__(self, source: str, server: str = None, mask: str = None) -> None:
        self.source = source
        self.server = server
        self.mask = mask

    def __repr__(self) -> str:
        return 'Links(source={}, server={}, mask={})'.format(repr(self.source), repr(self.server), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'LINKS':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = len(line.arguments) - 1
        if len(line.arguments) > 0:
            server = decode(line.arguments[i])
            i -= 1
        else:
            server = None
        if len(line.arguments) > 1:
            mask = decode(line.arguments[i])
            i -= 1
        else:
            mask = None
        assert i == -1
        return cls(source=source, server=server, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.server is not None:
            arguments.append(encode(self.server))
        if self.mask is not None:
            arguments.append(encode(self.mask))
        return Line(source, b'LINKS', arguments)


class Time(Message):
    """
    ``TIME [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Time(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'TIME':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'TIME', arguments)


class ServerConnect(Message):
    """
    ``CONNECT <target> <int:port> [remote]``
    """

    __slots__ = ['target', 'port', 'remote']

    def __init__(self, source: str, target: str, port: int, remote: str = None) -> None:
        self.source = source
        self.target = target
        self.port = port
        self.remote = remote

    def __repr__(self) -> str:
        return 'ServerConnect(source={}, target={}, port={}, remote={})'.format(repr(self.source), repr(self.target), repr(self.port), repr(self.remote))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'CONNECT':
            raise ValueError("incorrect verb")
        if not (2 <= len(line.arguments) <= 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        port = int(line.arguments[i])
        i += 1
        if len(line.arguments) > 2:
            remote = decode(line.arguments[i])
            i += 1
        else:
            remote = None
        assert i == len(line.arguments)
        return cls(source=source, target=target, port=port, remote=remote)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(str(self.port)))
        if self.remote is not None:
            arguments.append(encode(self.remote))
        return Line(source, b'CONNECT', arguments)


class Trace(Message):
    """
    ``TRACE [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Trace(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'TRACE':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'TRACE', arguments)


class Admin(Message):
    """
    ``ADMIN [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Admin(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'ADMIN':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'ADMIN', arguments)


class Info(Message):
    """
    ``INFO [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Info(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'INFO':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'INFO', arguments)


class ServList(Message):
    """
    ``SERVLIST [mask] [type]``
    """

    __slots__ = ['mask', 'type']

    def __init__(self, source: str, mask: str = None, type: str = None) -> None:
        self.source = source
        self.mask = mask
        self.type = type

    def __repr__(self) -> str:
        return 'ServList(source={}, mask={}, type={})'.format(repr(self.source), repr(self.mask), repr(self.type))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'SERVLIST':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            mask = decode(line.arguments[i])
            i += 1
        else:
            mask = None
        if len(line.arguments) > 1:
            type = decode(line.arguments[i])
            i += 1
        else:
            type = None
        assert i == len(line.arguments)
        return cls(source=source, mask=mask, type=type)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.mask is not None:
            arguments.append(encode(self.mask))
        if self.type is not None:
            arguments.append(encode(self.type))
        return Line(source, b'SERVLIST', arguments)


class SQuery(Message):
    """
    ``SQUERY <servicename> <text>``
    """

    __slots__ = ['servicename', 'text']

    def __init__(self, source: str, servicename: str, text: str) -> None:
        self.source = source
        self.servicename = servicename
        self.text = text

    def __repr__(self) -> str:
        return 'SQuery(source={}, servicename={}, text={})'.format(repr(self.source), repr(self.servicename), repr(self.text))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'SQUERY':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        servicename = decode(line.arguments[i])
        i += 1
        text = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, servicename=servicename, text=text)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.servicename))
        arguments.append(encode(self.text))
        return Line(source, b'SQUERY', arguments)


class Who(Message):
    """
    ``WHO [mask] [flag(o):operators]``
    """

    __slots__ = ['mask', 'operators']

    def __init__(self, source: str, mask: str = None, operators: bool = None) -> None:
        self.source = source
        self.mask = mask
        self.operators = operators

    def __repr__(self) -> str:
        return 'Who(source={}, mask={}, operators={})'.format(repr(self.source), repr(self.mask), repr(self.operators))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'WHO':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            mask = decode(line.arguments[i])
            i += 1
        else:
            mask = None
        if len(line.arguments) > 1:
            operators = True
            i += 1
        else:
            operators = False
        assert i == len(line.arguments)
        return cls(source=source, mask=mask, operators=operators)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.mask is not None:
            arguments.append(encode(self.mask))
        if self.operators is not None:
            arguments.append(b'o')
        return Line(source, b'WHO', arguments)


class WhoIs(Message):
    """
    ``WHOIS [target] <masks,>``
    """

    __slots__ = ['target', 'masks']

    def __init__(self, source: str, masks: typing.List[str], target: str = None) -> None:
        self.source = source
        self.target = target
        self.masks = masks

    def __repr__(self) -> str:
        return 'WhoIs(source={}, target={}, masks={})'.format(repr(self.source), repr(self.target), repr(self.masks))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'WHOIS':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 1:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        masks = [decode(x) for x in line.arguments[i].split(b",")]
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, masks=masks)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        arguments.append(b",".join(encode(x) for x in self.masks))
        return Line(source, b'WHOIS', arguments)


class WhoWas(Message):
    """
    ``WHOWAS <nicknames,> [int:count] [target]``
    """

    __slots__ = ['nicknames', 'count', 'target']

    def __init__(self, source: str, nicknames: typing.List[str], count: int = None, target: str = None) -> None:
        self.source = source
        self.nicknames = nicknames
        self.count = count
        self.target = target

    def __repr__(self) -> str:
        return 'WhoWas(source={}, nicknames={}, count={}, target={})'.format(repr(self.source), repr(self.nicknames), repr(self.count), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'WHOWAS':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 3):
            raise ValueError("wrong number of arguments")
        i = 0
        nicknames = [decode(x) for x in line.arguments[i].split(b",")]
        i += 1
        if len(line.arguments) > 1:
            count = int(line.arguments[i])
            i += 1
        else:
            count = None
        if len(line.arguments) > 2:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, nicknames=nicknames, count=count, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(b",".join(encode(x) for x in self.nicknames))
        if self.count is not None:
            arguments.append(encode(str(self.count)))
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'WHOWAS', arguments)


class Kill(Message):
    """
    ``KILL <nickname> <comment>``
    """

    __slots__ = ['nickname', 'comment']

    def __init__(self, source: str, nickname: str, comment: str) -> None:
        self.source = source
        self.nickname = nickname
        self.comment = comment

    def __repr__(self) -> str:
        return 'Kill(source={}, nickname={}, comment={})'.format(repr(self.source), repr(self.nickname), repr(self.comment))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'KILL':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        nickname = decode(line.arguments[i])
        i += 1
        comment = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, nickname=nickname, comment=comment)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.comment))
        return Line(source, b'KILL', arguments)


class Ping(Message):
    """
    ``PING <server1> [server2]``
    """

    __slots__ = ['server1', 'server2']

    def __init__(self, source: str, server1: str, server2: str = None) -> None:
        self.source = source
        self.server1 = server1
        self.server2 = server2

    def __repr__(self) -> str:
        return 'Ping(source={}, server1={}, server2={})'.format(repr(self.source), repr(self.server1), repr(self.server2))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'PING':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        server1 = decode(line.arguments[i])
        i += 1
        if len(line.arguments) > 1:
            server2 = decode(line.arguments[i])
            i += 1
        else:
            server2 = None
        assert i == len(line.arguments)
        return cls(source=source, server1=server1, server2=server2)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.server1))
        if self.server2 is not None:
            arguments.append(encode(self.server2))
        return Line(source, b'PING', arguments)


class Pong(Message):
    """
    ``PONG <server> [server2]``
    """

    __slots__ = ['server', 'server2']

    def __init__(self, source: str, server: str, server2: str = None) -> None:
        self.source = source
        self.server = server
        self.server2 = server2

    def __repr__(self) -> str:
        return 'Pong(source={}, server={}, server2={})'.format(repr(self.source), repr(self.server), repr(self.server2))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'PONG':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 2):
            raise ValueError("wrong number of arguments")
        i = 0
        server = decode(line.arguments[i])
        i += 1
        if len(line.arguments) > 1:
            server2 = decode(line.arguments[i])
            i += 1
        else:
            server2 = None
        assert i == len(line.arguments)
        return cls(source=source, server=server, server2=server2)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.server))
        if self.server2 is not None:
            arguments.append(encode(self.server2))
        return Line(source, b'PONG', arguments)


class Error(Message):
    """
    ``ERROR <message>``
    """

    __slots__ = ['message']

    def __init__(self, source: str, message: str) -> None:
        self.source = source
        self.message = message

    def __repr__(self) -> str:
        return 'Error(source={}, message={})'.format(repr(self.source), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'ERROR':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.message))
        return Line(source, b'ERROR', arguments)


class Away(Message):
    """
    ``AWAY [text]``
    """

    __slots__ = ['text']

    def __init__(self, source: str, text: str = None) -> None:
        self.source = source
        self.text = text

    def __repr__(self) -> str:
        return 'Away(source={}, text={})'.format(repr(self.source), repr(self.text))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'AWAY':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            text = decode(line.arguments[i])
            i += 1
        else:
            text = None
        assert i == len(line.arguments)
        return cls(source=source, text=text)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.text is not None:
            arguments.append(encode(self.text))
        return Line(source, b'AWAY', arguments)


class Rehash(Message):
    """
    ``REHASH``
    """

    def __init__(self, source: str) -> None:
        self.source = source

    def __repr__(self) -> str:
        return 'Rehash(source={})'.format(repr(self.source))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'REHASH':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 0):
            raise ValueError("wrong number of arguments")
        return cls(source=source)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        return Line(source, b'REHASH')


class Die(Message):
    """
    ``DIE``
    """

    def __init__(self, source: str) -> None:
        self.source = source

    def __repr__(self) -> str:
        return 'Die(source={})'.format(repr(self.source))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'DIE':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 0):
            raise ValueError("wrong number of arguments")
        return cls(source=source)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        return Line(source, b'DIE')


class Restart(Message):
    """
    ``RESTART``
    """

    def __init__(self, source: str) -> None:
        self.source = source

    def __repr__(self) -> str:
        return 'Restart(source={})'.format(repr(self.source))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'RESTART':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 0):
            raise ValueError("wrong number of arguments")
        return cls(source=source)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        return Line(source, b'RESTART')


class Summon(Message):
    """
    ``SUMMON <user> [target] [channel]``
    """

    __slots__ = ['user', 'target', 'channel']

    def __init__(self, source: str, user: str, target: str = None, channel: str = None) -> None:
        self.source = source
        self.user = user
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'Summon(source={}, user={}, target={}, channel={})'.format(repr(self.source), repr(self.user), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'SUMMON':
            raise ValueError("incorrect verb")
        if not (1 <= len(line.arguments) <= 3):
            raise ValueError("wrong number of arguments")
        i = 0
        user = decode(line.arguments[i])
        i += 1
        if len(line.arguments) > 1:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        if len(line.arguments) > 2:
            channel = decode(line.arguments[i])
            i += 1
        else:
            channel = None
        assert i == len(line.arguments)
        return cls(source=source, user=user, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.user))
        if self.target is not None:
            arguments.append(encode(self.target))
        if self.channel is not None:
            arguments.append(encode(self.channel))
        return Line(source, b'SUMMON', arguments)


class Users(Message):
    """
    ``USERS [target]``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str = None) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Users(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'USERS':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) <= 1):
            raise ValueError("wrong number of arguments")
        i = 0
        if len(line.arguments) > 0:
            target = decode(line.arguments[i])
            i += 1
        else:
            target = None
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        if self.target is not None:
            arguments.append(encode(self.target))
        return Line(source, b'USERS', arguments)


class WallOps(Message):
    """
    ``WALLOPS <message>``
    """

    __slots__ = ['message']

    def __init__(self, source: str, message: str) -> None:
        self.source = source
        self.message = message

    def __repr__(self) -> str:
        return 'WallOps(source={}, message={})'.format(repr(self.source), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'WALLOPS':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.message))
        return Line(source, b'WALLOPS', arguments)


class UserHost(Message):
    """
    ``USERHOST <nickname>``

    FIXME many nicknames.
    """

    __slots__ = ['nickname']

    def __init__(self, source: str, nickname: str) -> None:
        self.source = source
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'UserHost(source={}, nickname={})'.format(repr(self.source), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'USERHOST':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        nickname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.nickname))
        return Line(source, b'USERHOST', arguments)


class IsOn(Message):
    """
    ``ISON <nickname>``

    FIXME many nicknames.
    """

    __slots__ = ['nickname']

    def __init__(self, source: str, nickname: str) -> None:
        self.source = source
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'IsOn(source={}, nickname={})'.format(repr(self.source), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != b'ISON':
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        nickname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.nickname))
        return Line(source, b'ISON', arguments)


class Welcome(Message):
    """
    ``001 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'Welcome(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 1:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"001", arguments)


class YourHost(Message):
    """
    ``002 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'YourHost(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 2:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"002", arguments)


class Created(Message):
    """
    ``003 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'Created(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 3:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"003", arguments)


class MyInfo(Message):
    """
    ``004 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'MyInfo(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 4:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"004", arguments)


class Bounce(Message):
    """
    ``005 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'Bounce(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 5:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"005", arguments)


class TraceLinkReply(Message):
    """
    ``200 <target> Link <version> <destination> <next> <protocol-version> <link-uptime> <back-send-q> <up-send-q>``
    """

    __slots__ = ['target', 'version', 'destination', 'next', 'protocol_version', 'link_uptime', 'back_send_q', 'up_send_q']

    def __init__(self, source: str, target: str, version: str, destination: str, next: str, protocol_version: str, link_uptime: str, back_send_q: str, up_send_q: str) -> None:
        self.source = source
        self.target = target
        self.version = version
        self.destination = destination
        self.next = next
        self.protocol_version = protocol_version
        self.link_uptime = link_uptime
        self.back_send_q = back_send_q
        self.up_send_q = up_send_q

    def __repr__(self) -> str:
        return 'TraceLinkReply(source={}, target={}, version={}, destination={}, next={}, protocol_version={}, link_uptime={}, back_send_q={}, up_send_q={})'.format(repr(self.source), repr(self.target), repr(self.version), repr(self.destination), repr(self.next), repr(self.protocol_version), repr(self.link_uptime), repr(self.back_send_q), repr(self.up_send_q))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 200:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 9):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Link'
        i += 1
        version = decode(line.arguments[i])
        i += 1
        destination = decode(line.arguments[i])
        i += 1
        next = decode(line.arguments[i])
        i += 1
        protocol_version = decode(line.arguments[i])
        i += 1
        link_uptime = decode(line.arguments[i])
        i += 1
        back_send_q = decode(line.arguments[i])
        i += 1
        up_send_q = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, version=version, destination=destination, next=next, protocol_version=protocol_version, link_uptime=link_uptime, back_send_q=back_send_q, up_send_q=up_send_q)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Link')
        arguments.append(encode(self.version))
        arguments.append(encode(self.destination))
        arguments.append(encode(self.next))
        arguments.append(encode(self.protocol_version))
        arguments.append(encode(self.link_uptime))
        arguments.append(encode(self.back_send_q))
        arguments.append(encode(self.up_send_q))
        return Line(source, b"200", arguments)


class TraceConnecting(Message):
    """
    ``201 <target> Try. <class> <server>``
    """

    __slots__ = ['target', 'klass', 'server']

    def __init__(self, source: str, target: str, klass: str, server: str) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.server = server

    def __repr__(self) -> str:
        return 'TraceConnecting(source={}, target={}, klass={}, server={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.server))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 201:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Try.'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, server=server)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Try.')
        arguments.append(encode(self.klass))
        arguments.append(encode(self.server))
        return Line(source, b"201", arguments)


class TraceHandshake(Message):
    """
    ``202 <target> H.S. <class> <server>``
    """

    __slots__ = ['target', 'klass', 'server']

    def __init__(self, source: str, target: str, klass: str, server: str) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.server = server

    def __repr__(self) -> str:
        return 'TraceHandshake(source={}, target={}, klass={}, server={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.server))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 202:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'H.S.'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, server=server)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'H.S.')
        arguments.append(encode(self.klass))
        arguments.append(encode(self.server))
        return Line(source, b"202", arguments)


class TraceUnknown(Message):
    """
    ``203 <target> ???? <class> [ip]``
    """

    __slots__ = ['target', 'klass', 'ip']

    def __init__(self, source: str, target: str, klass: str, ip: str = None) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.ip = ip

    def __repr__(self) -> str:
        return 'TraceUnknown(source={}, target={}, klass={}, ip={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.ip))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 203:
            raise ValueError("incorrect verb")
        if not (3 <= len(line.arguments) <= 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: '????'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        if len(line.arguments) > 3:
            ip = decode(line.arguments[i])
            i += 1
        else:
            ip = None
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, ip=ip)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'????')
        arguments.append(encode(self.klass))
        if self.ip is not None:
            arguments.append(encode(self.ip))
        return Line(source, b"203", arguments)


class TraceOperator(Message):
    """
    ``204 <target> Oper <class> <nickname>``
    """

    __slots__ = ['target', 'klass', 'nickname']

    def __init__(self, source: str, target: str, klass: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'TraceOperator(source={}, target={}, klass={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 204:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Oper'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Oper')
        arguments.append(encode(self.klass))
        arguments.append(encode(self.nickname))
        return Line(source, b"204", arguments)


class TraceUser(Message):
    """
    ``205 <target> User <class> <nickname>``
    """

    __slots__ = ['target', 'klass', 'nickname']

    def __init__(self, source: str, target: str, klass: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'TraceUser(source={}, target={}, klass={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 205:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'User'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'User')
        arguments.append(encode(self.klass))
        arguments.append(encode(self.nickname))
        return Line(source, b"205", arguments)


class TraceServer(Message):
    """
    ``206 <target> Serv <class> <s> <c> <server> <hostmask> <protocol-version>``
    """

    __slots__ = ['target', 'klass', 's', 'c', 'server', 'hostmask', 'protocol_version']

    def __init__(self, source: str, target: str, klass: str, s: str, c: str, server: str, hostmask: str, protocol_version: str) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.s = s
        self.c = c
        self.server = server
        self.hostmask = hostmask
        self.protocol_version = protocol_version

    def __repr__(self) -> str:
        return 'TraceServer(source={}, target={}, klass={}, s={}, c={}, server={}, hostmask={}, protocol_version={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.s), repr(self.c), repr(self.server), repr(self.hostmask), repr(self.protocol_version))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 206:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 8):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Serv'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        s = decode(line.arguments[i])
        i += 1
        c = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        hostmask = decode(line.arguments[i])
        i += 1
        protocol_version = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, s=s, c=c, server=server, hostmask=hostmask, protocol_version=protocol_version)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Serv')
        arguments.append(encode(self.klass))
        arguments.append(encode(self.s))
        arguments.append(encode(self.c))
        arguments.append(encode(self.server))
        arguments.append(encode(self.hostmask))
        arguments.append(encode(self.protocol_version))
        return Line(source, b"206", arguments)


class TraceService(Message):
    """
    ``207 <target> Service <class> <name> <type> <active-type>``
    """

    __slots__ = ['target', 'klass', 'name', 'type', 'active_type']

    def __init__(self, source: str, target: str, klass: str, name: str, type: str, active_type: str) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.name = name
        self.type = type
        self.active_type = active_type

    def __repr__(self) -> str:
        return 'TraceService(source={}, target={}, klass={}, name={}, type={}, active_type={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.name), repr(self.type), repr(self.active_type))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 207:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 6):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Service'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        name = decode(line.arguments[i])
        i += 1
        type = decode(line.arguments[i])
        i += 1
        active_type = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, name=name, type=type, active_type=active_type)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Service')
        arguments.append(encode(self.klass))
        arguments.append(encode(self.name))
        arguments.append(encode(self.type))
        arguments.append(encode(self.active_type))
        return Line(source, b"207", arguments)


class TraceNewtype(Message):
    """
    ``208 <target> <newtype> 0 <name>``
    """

    __slots__ = ['target', 'newtype', 'name']

    def __init__(self, source: str, target: str, newtype: str, name: str) -> None:
        self.source = source
        self.target = target
        self.newtype = newtype
        self.name = name

    def __repr__(self) -> str:
        return 'TraceNewtype(source={}, target={}, newtype={}, name={})'.format(repr(self.source), repr(self.target), repr(self.newtype), repr(self.name))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 208:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        newtype = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: '0'
        i += 1
        name = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, newtype=newtype, name=name)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.newtype))
        arguments.append(b'0')
        arguments.append(encode(self.name))
        return Line(source, b"208", arguments)


class TraceClass(Message):
    """
    ``209 <target> Class <class> <int:count>``
    """

    __slots__ = ['target', 'klass', 'count']

    def __init__(self, source: str, target: str, klass: str, count: int) -> None:
        self.source = source
        self.target = target
        self.klass = klass
        self.count = count

    def __repr__(self) -> str:
        return 'TraceClass(source={}, target={}, klass={}, count={})'.format(repr(self.source), repr(self.target), repr(self.klass), repr(self.count))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 209:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Class'
        i += 1
        klass = decode(line.arguments[i])
        i += 1
        count = int(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, klass=klass, count=count)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Class')
        arguments.append(encode(self.klass))
        arguments.append(encode(str(self.count)))
        return Line(source, b"209", arguments)


class StatsLinkInfo(Message):
    """
    ``211 <target> <name> <sendq> <int:sent-messages> <int:sent-kbytes> <int:recv-messages> <int:recv-kbytes> <int:uptime>``
    """

    __slots__ = ['target', 'name', 'sendq', 'sent_messages', 'sent_kbytes', 'recv_messages', 'recv_kbytes', 'uptime']

    def __init__(self, source: str, target: str, name: str, sendq: str, sent_messages: int, sent_kbytes: int, recv_messages: int, recv_kbytes: int, uptime: int) -> None:
        self.source = source
        self.target = target
        self.name = name
        self.sendq = sendq
        self.sent_messages = sent_messages
        self.sent_kbytes = sent_kbytes
        self.recv_messages = recv_messages
        self.recv_kbytes = recv_kbytes
        self.uptime = uptime

    def __repr__(self) -> str:
        return 'StatsLinkInfo(source={}, target={}, name={}, sendq={}, sent_messages={}, sent_kbytes={}, recv_messages={}, recv_kbytes={}, uptime={})'.format(repr(self.source), repr(self.target), repr(self.name), repr(self.sendq), repr(self.sent_messages), repr(self.sent_kbytes), repr(self.recv_messages), repr(self.recv_kbytes), repr(self.uptime))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 211:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 8):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        name = decode(line.arguments[i])
        i += 1
        sendq = decode(line.arguments[i])
        i += 1
        sent_messages = int(line.arguments[i])
        i += 1
        sent_kbytes = int(line.arguments[i])
        i += 1
        recv_messages = int(line.arguments[i])
        i += 1
        recv_kbytes = int(line.arguments[i])
        i += 1
        uptime = int(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, name=name, sendq=sendq, sent_messages=sent_messages, sent_kbytes=sent_kbytes, recv_messages=recv_messages, recv_kbytes=recv_kbytes, uptime=uptime)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.name))
        arguments.append(encode(self.sendq))
        arguments.append(encode(str(self.sent_messages)))
        arguments.append(encode(str(self.sent_kbytes)))
        arguments.append(encode(str(self.recv_messages)))
        arguments.append(encode(str(self.recv_kbytes)))
        arguments.append(encode(str(self.uptime)))
        return Line(source, b"211", arguments)


class StatsCommands(Message):
    """
    ``212 <target> <command> <int:count> <int:bytes> <int:remote-count>``
    """

    __slots__ = ['target', 'command', 'count', 'bytecount', 'remote_count']

    def __init__(self, source: str, target: str, command: str, count: int, bytecount: int, remote_count: int) -> None:
        self.source = source
        self.target = target
        self.command = command
        self.count = count
        self.bytecount = bytecount
        self.remote_count = remote_count

    def __repr__(self) -> str:
        return 'StatsCommands(source={}, target={}, command={}, count={}, bytecount={}, remote_count={})'.format(repr(self.source), repr(self.target), repr(self.command), repr(self.count), repr(self.bytecount), repr(self.remote_count))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 212:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 5):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        command = decode(line.arguments[i])
        i += 1
        count = int(line.arguments[i])
        i += 1
        bytecount = int(line.arguments[i])
        i += 1
        remote_count = int(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, command=command, count=count, bytecount=bytecount, remote_count=remote_count)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.command))
        arguments.append(encode(str(self.count)))
        arguments.append(encode(str(self.bytecount)))
        arguments.append(encode(str(self.remote_count)))
        return Line(source, b"212", arguments)


class StatsEnd(Message):
    """
    ``219 <target> <letter> :End of STATS report``
    """

    __slots__ = ['target', 'letter']

    def __init__(self, source: str, target: str, letter: str) -> None:
        self.source = source
        self.target = target
        self.letter = letter

    def __repr__(self) -> str:
        return 'StatsEnd(source={}, target={}, letter={})'.format(repr(self.source), repr(self.target), repr(self.letter))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 219:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        letter = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of STATS report'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, letter=letter)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.letter))
        arguments.append(b'End of STATS report')
        return Line(source, b"219", arguments)


class UserModeIs(Message):
    """
    ``221 <target> <mode>``
    """

    __slots__ = ['target', 'mode']

    def __init__(self, source: str, target: str, mode: str) -> None:
        self.source = source
        self.target = target
        self.mode = mode

    def __repr__(self) -> str:
        return 'UserModeIs(source={}, target={}, mode={})'.format(repr(self.source), repr(self.target), repr(self.mode))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 221:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mode = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mode=mode)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mode))
        return Line(source, b"221", arguments)


class ServListReply(Message):
    """
    ``234 <target> <name> <server> <mask> <type> <int:hopcount> <info>``
    """

    __slots__ = ['target', 'name', 'server', 'mask', 'type', 'hopcount', 'info']

    def __init__(self, source: str, target: str, name: str, server: str, mask: str, type: str, hopcount: int, info: str) -> None:
        self.source = source
        self.target = target
        self.name = name
        self.server = server
        self.mask = mask
        self.type = type
        self.hopcount = hopcount
        self.info = info

    def __repr__(self) -> str:
        return 'ServListReply(source={}, target={}, name={}, server={}, mask={}, type={}, hopcount={}, info={})'.format(repr(self.source), repr(self.target), repr(self.name), repr(self.server), repr(self.mask), repr(self.type), repr(self.hopcount), repr(self.info))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 234:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 7):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        name = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        type = decode(line.arguments[i])
        i += 1
        hopcount = int(line.arguments[i])
        i += 1
        info = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, name=name, server=server, mask=mask, type=type, hopcount=hopcount, info=info)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.name))
        arguments.append(encode(self.server))
        arguments.append(encode(self.mask))
        arguments.append(encode(self.type))
        arguments.append(encode(str(self.hopcount)))
        arguments.append(encode(self.info))
        return Line(source, b"234", arguments)


class ServListEnd(Message):
    """
    ``235 <target> <mask> <type> :End of service listing``
    """

    __slots__ = ['target', 'mask', 'type']

    def __init__(self, source: str, target: str, mask: str, type: str) -> None:
        self.source = source
        self.target = target
        self.mask = mask
        self.type = type

    def __repr__(self) -> str:
        return 'ServListEnd(source={}, target={}, mask={}, type={})'.format(repr(self.source), repr(self.target), repr(self.mask), repr(self.type))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 235:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        type = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of service listing'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mask=mask, type=type)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mask))
        arguments.append(encode(self.type))
        arguments.append(b'End of service listing')
        return Line(source, b"235", arguments)


class StatsUptime(Message):
    """
    ``242 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'StatsUptime(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 242:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"242", arguments)


class StatsOline(Message):
    """
    ``243 <target> O <hostmask> * <name>``
    """

    __slots__ = ['target', 'hostmask', 'name']

    def __init__(self, source: str, target: str, hostmask: str, name: str) -> None:
        self.source = source
        self.target = target
        self.hostmask = hostmask
        self.name = name

    def __repr__(self) -> str:
        return 'StatsOline(source={}, target={}, hostmask={}, name={})'.format(repr(self.source), repr(self.target), repr(self.hostmask), repr(self.name))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 243:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 5):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'O'
        i += 1
        hostmask = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: '*'
        i += 1
        name = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, hostmask=hostmask, name=name)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'O')
        arguments.append(encode(self.hostmask))
        arguments.append(b'*')
        arguments.append(encode(self.name))
        return Line(source, b"243", arguments)


class LuserClient(Message):
    """
    ``251 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'LuserClient(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 251:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"251", arguments)


class LuserOp(Message):
    """
    ``252 <target> <int:count> :operator(s) online``
    """

    __slots__ = ['target', 'count']

    def __init__(self, source: str, target: str, count: int) -> None:
        self.source = source
        self.target = target
        self.count = count

    def __repr__(self) -> str:
        return 'LuserOp(source={}, target={}, count={})'.format(repr(self.source), repr(self.target), repr(self.count))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 252:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        count = int(line.arguments[i])
        i += 1
        # line.arguments[i]: 'operator(s) online'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, count=count)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(str(self.count)))
        arguments.append(b'operator(s) online')
        return Line(source, b"252", arguments)


class LuserUnknown(Message):
    """
    ``253 <target> <int:count> :unknown connection(s)``
    """

    __slots__ = ['target', 'count']

    def __init__(self, source: str, target: str, count: int) -> None:
        self.source = source
        self.target = target
        self.count = count

    def __repr__(self) -> str:
        return 'LuserUnknown(source={}, target={}, count={})'.format(repr(self.source), repr(self.target), repr(self.count))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 253:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        count = int(line.arguments[i])
        i += 1
        # line.arguments[i]: 'unknown connection(s)'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, count=count)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(str(self.count)))
        arguments.append(b'unknown connection(s)')
        return Line(source, b"253", arguments)


class LuserChannels(Message):
    """
    ``254 <target> <int:count> :channels formed``
    """

    __slots__ = ['target', 'count']

    def __init__(self, source: str, target: str, count: int) -> None:
        self.source = source
        self.target = target
        self.count = count

    def __repr__(self) -> str:
        return 'LuserChannels(source={}, target={}, count={})'.format(repr(self.source), repr(self.target), repr(self.count))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 254:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        count = int(line.arguments[i])
        i += 1
        # line.arguments[i]: 'channels formed'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, count=count)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(str(self.count)))
        arguments.append(b'channels formed')
        return Line(source, b"254", arguments)


class LuserMe(Message):
    """
    ``255 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'LuserMe(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 255:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"255", arguments)


class AdminMe(Message):
    """
    ``256 <target> <server> :Administrative info``
    """

    __slots__ = ['target', 'server']

    def __init__(self, source: str, target: str, server: str) -> None:
        self.source = source
        self.target = target
        self.server = server

    def __repr__(self) -> str:
        return 'AdminMe(source={}, target={}, server={})'.format(repr(self.source), repr(self.target), repr(self.server))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 256:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Administrative info'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, server=server)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.server))
        arguments.append(b'Administrative info')
        return Line(source, b"256", arguments)


class AdminLoc1(Message):
    """
    ``257 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'AdminLoc1(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 257:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"257", arguments)


class AdminLoc2(Message):
    """
    ``258 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'AdminLoc2(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 258:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"258", arguments)


class AdminEmail(Message):
    """
    ``259 <target> <email>``
    """

    __slots__ = ['target', 'email']

    def __init__(self, source: str, target: str, email: str) -> None:
        self.source = source
        self.target = target
        self.email = email

    def __repr__(self) -> str:
        return 'AdminEmail(source={}, target={}, email={})'.format(repr(self.source), repr(self.target), repr(self.email))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 259:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        email = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, email=email)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.email))
        return Line(source, b"259", arguments)


class TraceLog(Message):
    """
    ``261 <target> File <logfile> <debug-level>``
    """

    __slots__ = ['target', 'logfile', 'debug_level']

    def __init__(self, source: str, target: str, logfile: str, debug_level: str) -> None:
        self.source = source
        self.target = target
        self.logfile = logfile
        self.debug_level = debug_level

    def __repr__(self) -> str:
        return 'TraceLog(source={}, target={}, logfile={}, debug_level={})'.format(repr(self.source), repr(self.target), repr(self.logfile), repr(self.debug_level))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 261:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'File'
        i += 1
        logfile = decode(line.arguments[i])
        i += 1
        debug_level = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, logfile=logfile, debug_level=debug_level)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'File')
        arguments.append(encode(self.logfile))
        arguments.append(encode(self.debug_level))
        return Line(source, b"261", arguments)


class TraceEnd(Message):
    """
    ``262 <target> <server> <version> :End of TRACE``
    """

    __slots__ = ['target', 'server', 'version']

    def __init__(self, source: str, target: str, server: str, version: str) -> None:
        self.source = source
        self.target = target
        self.server = server
        self.version = version

    def __repr__(self) -> str:
        return 'TraceEnd(source={}, target={}, server={}, version={})'.format(repr(self.source), repr(self.target), repr(self.server), repr(self.version))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 262:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        version = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of TRACE'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, server=server, version=version)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.server))
        arguments.append(encode(self.version))
        arguments.append(b'End of TRACE')
        return Line(source, b"262", arguments)


class TryAgain(Message):
    """
    ``263 <target> <command> :Please wait a while and try again.``
    """

    __slots__ = ['target', 'command']

    def __init__(self, source: str, target: str, command: str) -> None:
        self.source = source
        self.target = target
        self.command = command

    def __repr__(self) -> str:
        return 'TryAgain(source={}, target={}, command={})'.format(repr(self.source), repr(self.target), repr(self.command))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 263:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        command = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Please wait a while and try again.'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, command=command)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.command))
        arguments.append(b'Please wait a while and try again.')
        return Line(source, b"263", arguments)


class AwayReply(Message):
    """
    ``301 <target> <nickname> <message>``
    """

    __slots__ = ['target', 'nickname', 'message']

    def __init__(self, source: str, target: str, nickname: str, message: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.message = message

    def __repr__(self) -> str:
        return 'AwayReply(source={}, target={}, nickname={}, message={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 301:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.message))
        return Line(source, b"301", arguments)


class UserHostReply(Message):
    """
    ``302 <target> <message>``

    FIXME parse data!
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'UserHostReply(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 302:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"302", arguments)


class IsOnReply(Message):
    """
    ``303 <target> <message>``

    FIXME parse data!
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'IsOnReply(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 303:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"303", arguments)


class UnawayReply(Message):
    """
    ``305 <target> :You are no longer marked as being away``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UnawayReply(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 305:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'You are no longer marked as being away'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'You are no longer marked as being away')
        return Line(source, b"305", arguments)


class NowAwayReply(Message):
    """
    ``306 <target> :You have been marked as being away``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NowAwayReply(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 306:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'You have been marked as being away'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'You have been marked as being away')
        return Line(source, b"306", arguments)


class WhoIsUser(Message):
    """
    ``311 <target> <nickname> <user> <host> * <realname>``
    """

    __slots__ = ['target', 'nickname', 'user', 'host', 'realname']

    def __init__(self, source: str, target: str, nickname: str, user: str, host: str, realname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.user = user
        self.host = host
        self.realname = realname

    def __repr__(self) -> str:
        return 'WhoIsUser(source={}, target={}, nickname={}, user={}, host={}, realname={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.user), repr(self.host), repr(self.realname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 311:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 6):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        user = decode(line.arguments[i])
        i += 1
        host = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: '*'
        i += 1
        realname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, user=user, host=host, realname=realname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.user))
        arguments.append(encode(self.host))
        arguments.append(b'*')
        arguments.append(encode(self.realname))
        return Line(source, b"311", arguments)


class WhoIsServer(Message):
    """
    ``312 <target> <nickname> <server> <info>``
    """

    __slots__ = ['target', 'nickname', 'server', 'info']

    def __init__(self, source: str, target: str, nickname: str, server: str, info: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.server = server
        self.info = info

    def __repr__(self) -> str:
        return 'WhoIsServer(source={}, target={}, nickname={}, server={}, info={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.server), repr(self.info))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 312:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        info = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, server=server, info=info)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.server))
        arguments.append(encode(self.info))
        return Line(source, b"312", arguments)


class WhoIsOperator(Message):
    """
    ``313 <target> <nickname> :is an IRC operator``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'WhoIsOperator(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 313:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'is an IRC operator'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'is an IRC operator')
        return Line(source, b"313", arguments)


class WhoWasUser(Message):
    """
    ``314 <target> <nickname> <user> <host> * <realname>``
    """

    __slots__ = ['target', 'nickname', 'user', 'host', 'realname']

    def __init__(self, source: str, target: str, nickname: str, user: str, host: str, realname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.user = user
        self.host = host
        self.realname = realname

    def __repr__(self) -> str:
        return 'WhoWasUser(source={}, target={}, nickname={}, user={}, host={}, realname={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.user), repr(self.host), repr(self.realname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 314:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 6):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        user = decode(line.arguments[i])
        i += 1
        host = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: '*'
        i += 1
        realname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, user=user, host=host, realname=realname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.user))
        arguments.append(encode(self.host))
        arguments.append(b'*')
        arguments.append(encode(self.realname))
        return Line(source, b"314", arguments)


class WhoEnd(Message):
    """
    ``315 <target> <name> :End of WHO list``
    """

    __slots__ = ['target', 'name']

    def __init__(self, source: str, target: str, name: str) -> None:
        self.source = source
        self.target = target
        self.name = name

    def __repr__(self) -> str:
        return 'WhoEnd(source={}, target={}, name={})'.format(repr(self.source), repr(self.target), repr(self.name))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 315:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        name = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of WHO list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, name=name)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.name))
        arguments.append(b'End of WHO list')
        return Line(source, b"315", arguments)


class WhoIsIdle(Message):
    """
    ``317 <target> <nickname> <int:time> :seconds idle``
    """

    __slots__ = ['target', 'nickname', 'time']

    def __init__(self, source: str, target: str, nickname: str, time: int) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.time = time

    def __repr__(self) -> str:
        return 'WhoIsIdle(source={}, target={}, nickname={}, time={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.time))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 317:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        time = int(line.arguments[i])
        i += 1
        # line.arguments[i]: 'seconds idle'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, time=time)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(str(self.time)))
        arguments.append(b'seconds idle')
        return Line(source, b"317", arguments)


class WhoIsEnd(Message):
    """
    ``318 <target> <nickname> :End of WHOIS list``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'WhoIsEnd(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 318:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of WHOIS list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'End of WHOIS list')
        return Line(source, b"318", arguments)


class WhoIsChannels(Message):
    """
    ``319 <target> <nickname> <channels>``
    """

    __slots__ = ['target', 'nickname', 'channels']

    def __init__(self, source: str, target: str, nickname: str, channels: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.channels = channels

    def __repr__(self) -> str:
        return 'WhoIsChannels(source={}, target={}, nickname={}, channels={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.channels))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 319:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        channels = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, channels=channels)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.channels))
        return Line(source, b"319", arguments)


class ListReply(Message):
    """
    ``322 <target> <channel> <int:visible> <topic>``
    """

    __slots__ = ['target', 'channel', 'visible', 'topic']

    def __init__(self, source: str, target: str, channel: str, visible: int, topic: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.visible = visible
        self.topic = topic

    def __repr__(self) -> str:
        return 'ListReply(source={}, target={}, channel={}, visible={}, topic={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.visible), repr(self.topic))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 322:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        visible = int(line.arguments[i])
        i += 1
        topic = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, visible=visible, topic=topic)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(str(self.visible)))
        arguments.append(encode(self.topic))
        return Line(source, b"322", arguments)


class ListEnd(Message):
    """
    ``323 <target> :End of LIST``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'ListEnd(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 323:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of LIST'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'End of LIST')
        return Line(source, b"323", arguments)


class ChannelModeIs(Message):
    """
    ``324 <target> <channel> <mode> <params>``
    """

    __slots__ = ['target', 'channel', 'mode', 'params']

    def __init__(self, source: str, target: str, channel: str, mode: str, params: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.mode = mode
        self.params = params

    def __repr__(self) -> str:
        return 'ChannelModeIs(source={}, target={}, channel={}, mode={}, params={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.mode), repr(self.params))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 324:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        mode = decode(line.arguments[i])
        i += 1
        params = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, mode=mode, params=params)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.mode))
        arguments.append(encode(self.params))
        return Line(source, b"324", arguments)


class UniqOpIs(Message):
    """
    ``325 <target> <channel> <nickname>``
    """

    __slots__ = ['target', 'channel', 'nickname']

    def __init__(self, source: str, target: str, channel: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'UniqOpIs(source={}, target={}, channel={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 325:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.nickname))
        return Line(source, b"325", arguments)


class NoTopicReply(Message):
    """
    ``331 <target> <channel> :No topic is set``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'NoTopicReply(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 331:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No topic is set'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'No topic is set')
        return Line(source, b"331", arguments)


class TopicReply(Message):
    """
    ``332 <target> <channel> <topic>``
    """

    __slots__ = ['target', 'channel', 'topic']

    def __init__(self, source: str, target: str, channel: str, topic: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.topic = topic

    def __repr__(self) -> str:
        return 'TopicReply(source={}, target={}, channel={}, topic={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.topic))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 332:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        topic = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, topic=topic)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.topic))
        return Line(source, b"332", arguments)


class Inviting(Message):
    """
    ``341 <target> <channel> <nick>``
    """

    __slots__ = ['target', 'channel', 'nick']

    def __init__(self, source: str, target: str, channel: str, nick: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.nick = nick

    def __repr__(self) -> str:
        return 'Inviting(source={}, target={}, channel={}, nick={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.nick))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 341:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        nick = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, nick=nick)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.nick))
        return Line(source, b"341", arguments)


class Summoning(Message):
    """
    ``342 <target> <user> :Summoning user to IRC``
    """

    __slots__ = ['target', 'user']

    def __init__(self, source: str, target: str, user: str) -> None:
        self.source = source
        self.target = target
        self.user = user

    def __repr__(self) -> str:
        return 'Summoning(source={}, target={}, user={})'.format(repr(self.source), repr(self.target), repr(self.user))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 342:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        user = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Summoning user to IRC'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, user=user)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.user))
        arguments.append(b'Summoning user to IRC')
        return Line(source, b"342", arguments)


class InviteList(Message):
    """
    ``346 <target> <channel> <mask>``
    """

    __slots__ = ['target', 'channel', 'mask']

    def __init__(self, source: str, target: str, channel: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.mask = mask

    def __repr__(self) -> str:
        return 'InviteList(source={}, target={}, channel={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 346:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.mask))
        return Line(source, b"346", arguments)


class InviteListEnd(Message):
    """
    ``347 <target> <channel> :End of channel invite list``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'InviteListEnd(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 347:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of channel invite list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'End of channel invite list')
        return Line(source, b"347", arguments)


class ExceptList(Message):
    """
    ``348 <target> <channel> <mask>``
    """

    __slots__ = ['target', 'channel', 'mask']

    def __init__(self, source: str, target: str, channel: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.mask = mask

    def __repr__(self) -> str:
        return 'ExceptList(source={}, target={}, channel={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 348:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.mask))
        return Line(source, b"348", arguments)


class ExceptListEnd(Message):
    """
    ``349 <target> <channel> :End of channel exception list``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'ExceptListEnd(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 349:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of channel exception list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'End of channel exception list')
        return Line(source, b"349", arguments)


class VersionReply(Message):
    """
    ``351 <target> <version> <server> <comments>``
    """

    __slots__ = ['target', 'version', 'server', 'comments']

    def __init__(self, source: str, target: str, version: str, server: str, comments: str) -> None:
        self.source = source
        self.target = target
        self.version = version
        self.server = server
        self.comments = comments

    def __repr__(self) -> str:
        return 'VersionReply(source={}, target={}, version={}, server={}, comments={})'.format(repr(self.source), repr(self.target), repr(self.version), repr(self.server), repr(self.comments))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 351:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        version = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        comments = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, version=version, server=server, comments=comments)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.version))
        arguments.append(encode(self.server))
        arguments.append(encode(self.comments))
        return Line(source, b"351", arguments)


class WhoReply(Message):
    """
    ``352 <target> <channel> <user> <host> <server> <nickname> <props> <realname>``
    """

    __slots__ = ['target', 'channel', 'user', 'host', 'server', 'nickname', 'props', 'realname']

    def __init__(self, source: str, target: str, channel: str, user: str, host: str, server: str, nickname: str, props: str, realname: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.user = user
        self.host = host
        self.server = server
        self.nickname = nickname
        self.props = props
        self.realname = realname

    def __repr__(self) -> str:
        return 'WhoReply(source={}, target={}, channel={}, user={}, host={}, server={}, nickname={}, props={}, realname={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.user), repr(self.host), repr(self.server), repr(self.nickname), repr(self.props), repr(self.realname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 352:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 8):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        user = decode(line.arguments[i])
        i += 1
        host = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        props = decode(line.arguments[i])
        i += 1
        realname = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, user=user, host=host, server=server, nickname=nickname, props=props, realname=realname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.user))
        arguments.append(encode(self.host))
        arguments.append(encode(self.server))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.props))
        arguments.append(encode(self.realname))
        return Line(source, b"352", arguments)


class NamesReply(Message):
    """
    ``353 <target> <mode> <channel> <nicknames_>``
    """

    __slots__ = ['target', 'mode', 'channel', 'nicknames']

    def __init__(self, source: str, target: str, mode: str, channel: str, nicknames: typing.List[str]) -> None:
        self.source = source
        self.target = target
        self.mode = mode
        self.channel = channel
        self.nicknames = nicknames

    def __repr__(self) -> str:
        return 'NamesReply(source={}, target={}, mode={}, channel={}, nicknames={})'.format(repr(self.source), repr(self.target), repr(self.mode), repr(self.channel), repr(self.nicknames))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 353:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mode = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        nicknames = [decode(x) for x in line.arguments[i].split()]
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mode=mode, channel=channel, nicknames=nicknames)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mode))
        arguments.append(encode(self.channel))
        arguments.append(b" ".join(encode(x) for x in self.nicknames))
        return Line(source, b"353", arguments)


class LinksReply(Message):
    """
    ``364 <target> <mask> <server> <info>``
    """

    __slots__ = ['target', 'mask', 'server', 'info']

    def __init__(self, source: str, target: str, mask: str, server: str, info: str) -> None:
        self.source = source
        self.target = target
        self.mask = mask
        self.server = server
        self.info = info

    def __repr__(self) -> str:
        return 'LinksReply(source={}, target={}, mask={}, server={}, info={})'.format(repr(self.source), repr(self.target), repr(self.mask), repr(self.server), repr(self.info))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 364:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        info = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mask=mask, server=server, info=info)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mask))
        arguments.append(encode(self.server))
        arguments.append(encode(self.info))
        return Line(source, b"364", arguments)


class LinksEnd(Message):
    """
    ``365 <target> <mask> :End of LINKS list``
    """

    __slots__ = ['target', 'mask']

    def __init__(self, source: str, target: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.mask = mask

    def __repr__(self) -> str:
        return 'LinksEnd(source={}, target={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 365:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of LINKS list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mask))
        arguments.append(b'End of LINKS list')
        return Line(source, b"365", arguments)


class NamesEnd(Message):
    """
    ``366 <target> <channel> :End of NAMES list``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'NamesEnd(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 366:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of NAMES list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'End of NAMES list')
        return Line(source, b"366", arguments)


class BanList(Message):
    """
    ``367 <target> <channel> <mask>``
    """

    __slots__ = ['target', 'channel', 'mask']

    def __init__(self, source: str, target: str, channel: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.mask = mask

    def __repr__(self) -> str:
        return 'BanList(source={}, target={}, channel={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 367:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.mask))
        return Line(source, b"367", arguments)


class BanListEnd(Message):
    """
    ``368 <target> <channel> :End of channel ban list``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'BanListEnd(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 368:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of channel ban list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'End of channel ban list')
        return Line(source, b"368", arguments)


class WhoWasEnd(Message):
    """
    ``369 <target> <nickname> :End of WHOWAS``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'WhoWasEnd(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 369:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of WHOWAS'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'End of WHOWAS')
        return Line(source, b"369", arguments)


class InfoReply(Message):
    """
    ``371 <target> <info>``
    """

    __slots__ = ['target', 'info']

    def __init__(self, source: str, target: str, info: str) -> None:
        self.source = source
        self.target = target
        self.info = info

    def __repr__(self) -> str:
        return 'InfoReply(source={}, target={}, info={})'.format(repr(self.source), repr(self.target), repr(self.info))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 371:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        info = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, info=info)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.info))
        return Line(source, b"371", arguments)


class MotdText(Message):
    """
    ``372 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'MotdText(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 372:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"372", arguments)


class InfoEnd(Message):
    """
    ``374 <target> :End of INFO list``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'InfoEnd(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 374:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of INFO list'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'End of INFO list')
        return Line(source, b"374", arguments)


class MotdStart(Message):
    """
    ``375 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'MotdStart(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 375:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"375", arguments)


class MotdEnd(Message):
    """
    ``376 <target> :End of MOTD command``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'MotdEnd(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 376:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of MOTD command'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'End of MOTD command')
        return Line(source, b"376", arguments)


class YoureOper(Message):
    """
    ``381 <target> :You are now an IRC operator``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'YoureOper(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 381:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'You are now an IRC operator'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'You are now an IRC operator')
        return Line(source, b"381", arguments)


class Rehashing(Message):
    """
    ``382 <target> <file> Rehashing``
    """

    __slots__ = ['target', 'file']

    def __init__(self, source: str, target: str, file: str) -> None:
        self.source = source
        self.target = target
        self.file = file

    def __repr__(self) -> str:
        return 'Rehashing(source={}, target={}, file={})'.format(repr(self.source), repr(self.target), repr(self.file))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 382:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        file = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Rehashing'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, file=file)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.file))
        arguments.append(b'Rehashing')
        return Line(source, b"382", arguments)


class YoureService(Message):
    """
    ``383 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'YoureService(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 383:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"383", arguments)


class TimeReply(Message):
    """
    ``391 <target> <server> <time>``
    """

    __slots__ = ['target', 'server', 'time']

    def __init__(self, source: str, target: str, server: str, time: str) -> None:
        self.source = source
        self.target = target
        self.server = server
        self.time = time

    def __repr__(self) -> str:
        return 'TimeReply(source={}, target={}, server={}, time={})'.format(repr(self.source), repr(self.target), repr(self.server), repr(self.time))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 391:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        time = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, server=server, time=time)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.server))
        arguments.append(encode(self.time))
        return Line(source, b"391", arguments)


class UsersStart(Message):
    """
    ``392 <target> :UserID   Terminal  Host``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UsersStart(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 392:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'UserID   Terminal  Host'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'UserID   Terminal  Host')
        return Line(source, b"392", arguments)


class UsersReply(Message):
    """
    ``393 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'UsersReply(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 393:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"393", arguments)


class UsersEnd(Message):
    """
    ``394 <target> :End of users``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UsersEnd(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 394:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'End of users'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'End of users')
        return Line(source, b"394", arguments)


class NoUsers(Message):
    """
    ``395 <target> :Nobody logged in``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoUsers(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 395:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Nobody logged in'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Nobody logged in')
        return Line(source, b"395", arguments)


class NoSuchNick(Message):
    """
    ``401 <target> <nickname> :No such nick/channel``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'NoSuchNick(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 401:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No such nick/channel'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'No such nick/channel')
        return Line(source, b"401", arguments)


class NoSuchServer(Message):
    """
    ``402 <target> <server> :No such server``
    """

    __slots__ = ['target', 'server']

    def __init__(self, source: str, target: str, server: str) -> None:
        self.source = source
        self.target = target
        self.server = server

    def __repr__(self) -> str:
        return 'NoSuchServer(source={}, target={}, server={})'.format(repr(self.source), repr(self.target), repr(self.server))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 402:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No such server'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, server=server)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.server))
        arguments.append(b'No such server')
        return Line(source, b"402", arguments)


class NoSuchChannel(Message):
    """
    ``403 <target> <channel> :No such channel``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'NoSuchChannel(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 403:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No such channel'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'No such channel')
        return Line(source, b"403", arguments)


class CantSendToChan(Message):
    """
    ``404 <target> <channel> :Cannot send to channel``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'CantSendToChan(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 404:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Cannot send to channel'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Cannot send to channel')
        return Line(source, b"404", arguments)


class TooManyChannels(Message):
    """
    ``405 <target> <channel> :You have joined too many channels``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'TooManyChannels(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 405:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'You have joined too many channels'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'You have joined too many channels')
        return Line(source, b"405", arguments)


class WasNoSuchNick(Message):
    """
    ``406 <target> <nickname> :There was no such nickname``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'WasNoSuchNick(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 406:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'There was no such nickname'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'There was no such nickname')
        return Line(source, b"406", arguments)


class TooManyTargets(Message):
    """
    ``407 <target> <orig-target> <message>``
    """

    __slots__ = ['target', 'orig_target', 'message']

    def __init__(self, source: str, target: str, orig_target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.orig_target = orig_target
        self.message = message

    def __repr__(self) -> str:
        return 'TooManyTargets(source={}, target={}, orig_target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.orig_target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 407:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        orig_target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, orig_target=orig_target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.orig_target))
        arguments.append(encode(self.message))
        return Line(source, b"407", arguments)


class NoSuchService(Message):
    """
    ``408 <target> <name> :No such service``
    """

    __slots__ = ['target', 'name']

    def __init__(self, source: str, target: str, name: str) -> None:
        self.source = source
        self.target = target
        self.name = name

    def __repr__(self) -> str:
        return 'NoSuchService(source={}, target={}, name={})'.format(repr(self.source), repr(self.target), repr(self.name))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 408:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        name = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No such service'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, name=name)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.name))
        arguments.append(b'No such service')
        return Line(source, b"408", arguments)


class NoOrigin(Message):
    """
    ``409 <target> :No origin specified``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoOrigin(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 409:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No origin specified'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'No origin specified')
        return Line(source, b"409", arguments)


class NoRecipient(Message):
    """
    ``411 <target> :No recipient given``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoRecipient(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 411:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No recipient given'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'No recipient given')
        return Line(source, b"411", arguments)


class NoTextToSend(Message):
    """
    ``412 <target> :No text to send``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoTextToSend(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 412:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No text to send'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'No text to send')
        return Line(source, b"412", arguments)


class NoTopLevel(Message):
    """
    ``413 <target> <mask> :No toplevel domain specified``
    """

    __slots__ = ['target', 'mask']

    def __init__(self, source: str, target: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.mask = mask

    def __repr__(self) -> str:
        return 'NoTopLevel(source={}, target={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 413:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No toplevel domain specified'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mask))
        arguments.append(b'No toplevel domain specified')
        return Line(source, b"413", arguments)


class WildTopLevel(Message):
    """
    ``414 <target> <mask> :Wildcard in toplevel domain``
    """

    __slots__ = ['target', 'mask']

    def __init__(self, source: str, target: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.mask = mask

    def __repr__(self) -> str:
        return 'WildTopLevel(source={}, target={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 414:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Wildcard in toplevel domain'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mask))
        arguments.append(b'Wildcard in toplevel domain')
        return Line(source, b"414", arguments)


class BadMask(Message):
    """
    ``415 <target> <mask> :Bad Server/host mask``
    """

    __slots__ = ['target', 'mask']

    def __init__(self, source: str, target: str, mask: str) -> None:
        self.source = source
        self.target = target
        self.mask = mask

    def __repr__(self) -> str:
        return 'BadMask(source={}, target={}, mask={})'.format(repr(self.source), repr(self.target), repr(self.mask))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 415:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        mask = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Bad Server/host mask'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, mask=mask)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.mask))
        arguments.append(b'Bad Server/host mask')
        return Line(source, b"415", arguments)


class UnknownCommand(Message):
    """
    ``421 <target> <command> :Unknown command``
    """

    __slots__ = ['target', 'command']

    def __init__(self, source: str, target: str, command: str) -> None:
        self.source = source
        self.target = target
        self.command = command

    def __repr__(self) -> str:
        return 'UnknownCommand(source={}, target={}, command={})'.format(repr(self.source), repr(self.target), repr(self.command))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 421:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        command = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Unknown command'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, command=command)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.command))
        arguments.append(b'Unknown command')
        return Line(source, b"421", arguments)


class NoMotd(Message):
    """
    ``422 <target> :MOTD File is missing``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoMotd(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 422:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'MOTD File is missing'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'MOTD File is missing')
        return Line(source, b"422", arguments)


class NoAdminInfo(Message):
    """
    ``423 <target> <server> :No administrative info available``
    """

    __slots__ = ['target', 'server']

    def __init__(self, source: str, target: str, server: str) -> None:
        self.source = source
        self.target = target
        self.server = server

    def __repr__(self) -> str:
        return 'NoAdminInfo(source={}, target={}, server={})'.format(repr(self.source), repr(self.target), repr(self.server))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 423:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        server = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No administrative info available'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, server=server)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.server))
        arguments.append(b'No administrative info available')
        return Line(source, b"423", arguments)


class FileError(Message):
    """
    ``424 <target> <message>``
    """

    __slots__ = ['target', 'message']

    def __init__(self, source: str, target: str, message: str) -> None:
        self.source = source
        self.target = target
        self.message = message

    def __repr__(self) -> str:
        return 'FileError(source={}, target={}, message={})'.format(repr(self.source), repr(self.target), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 424:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.message))
        return Line(source, b"424", arguments)


class NoNicknameGiven(Message):
    """
    ``431 <target> :No nickname given``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoNicknameGiven(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 431:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No nickname given'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'No nickname given')
        return Line(source, b"431", arguments)


class ErroneusNickname(Message):
    """
    ``432 <target> <nickname> :Erroneous nickname``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'ErroneusNickname(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 432:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Erroneous nickname'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'Erroneous nickname')
        return Line(source, b"432", arguments)


class NicknameInUse(Message):
    """
    ``433 <target> <nickname> :Nickname is already in use``
    """

    __slots__ = ['target', 'nickname']

    def __init__(self, source: str, target: str, nickname: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname

    def __repr__(self) -> str:
        return 'NicknameInUse(source={}, target={}, nickname={})'.format(repr(self.source), repr(self.target), repr(self.nickname))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 433:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Nickname is already in use'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(b'Nickname is already in use')
        return Line(source, b"433", arguments)


class NickCollision(Message):
    """
    ``436 <target> <nickname> <message>``
    """

    __slots__ = ['target', 'nickname', 'message']

    def __init__(self, source: str, target: str, nickname: str, message: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.message = message

    def __repr__(self) -> str:
        return 'NickCollision(source={}, target={}, nickname={}, message={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.message))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 436:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        message = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, message=message)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.message))
        return Line(source, b"436", arguments)


class UnavailResource(Message):
    """
    ``437 <target> <name> :Nick/channel is temporarily unavailable``
    """

    __slots__ = ['target', 'name']

    def __init__(self, source: str, target: str, name: str) -> None:
        self.source = source
        self.target = target
        self.name = name

    def __repr__(self) -> str:
        return 'UnavailResource(source={}, target={}, name={})'.format(repr(self.source), repr(self.target), repr(self.name))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 437:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        name = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Nick/channel is temporarily unavailable'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, name=name)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.name))
        arguments.append(b'Nick/channel is temporarily unavailable')
        return Line(source, b"437", arguments)


class UserNotInChannel(Message):
    """
    ``441 <target> <nickname> <channel> :They aren't on that channel``
    """

    __slots__ = ['target', 'nickname', 'channel']

    def __init__(self, source: str, target: str, nickname: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.nickname = nickname
        self.channel = channel

    def __repr__(self) -> str:
        return 'UserNotInChannel(source={}, target={}, nickname={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.nickname), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 441:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        nickname = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "They aren't on that channel"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, nickname=nickname, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.nickname))
        arguments.append(encode(self.channel))
        arguments.append(b"They aren't on that channel")
        return Line(source, b"441", arguments)


class NotOnChannel(Message):
    """
    ``442 <target> <channel> :You're not on that channel``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'NotOnChannel(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 442:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "You're not on that channel"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b"You're not on that channel")
        return Line(source, b"442", arguments)


class UserOnChannel(Message):
    """
    ``443 <target> <user> <channel> :is already on channel``
    """

    __slots__ = ['target', 'user', 'channel']

    def __init__(self, source: str, target: str, user: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.user = user
        self.channel = channel

    def __repr__(self) -> str:
        return 'UserOnChannel(source={}, target={}, user={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.user), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 443:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        user = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'is already on channel'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, user=user, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.user))
        arguments.append(encode(self.channel))
        arguments.append(b'is already on channel')
        return Line(source, b"443", arguments)


class NoLogin(Message):
    """
    ``444 <target> <user> :User not logged in``
    """

    __slots__ = ['target', 'user']

    def __init__(self, source: str, target: str, user: str) -> None:
        self.source = source
        self.target = target
        self.user = user

    def __repr__(self) -> str:
        return 'NoLogin(source={}, target={}, user={})'.format(repr(self.source), repr(self.target), repr(self.user))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 444:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        user = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'User not logged in'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, user=user)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.user))
        arguments.append(b'User not logged in')
        return Line(source, b"444", arguments)


class SummonDisabled(Message):
    """
    ``445 <target> :SUMMON has been disabled``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'SummonDisabled(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 445:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'SUMMON has been disabled'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'SUMMON has been disabled')
        return Line(source, b"445", arguments)


class UsersDisabled(Message):
    """
    ``446 <target> :USERS has been disabled``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UsersDisabled(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 446:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'USERS has been disabled'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'USERS has been disabled')
        return Line(source, b"446", arguments)


class NotRegistered(Message):
    """
    ``451 <target> :You have not registered``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NotRegistered(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 451:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'You have not registered'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'You have not registered')
        return Line(source, b"451", arguments)


class NeedMoreParams(Message):
    """
    ``461 <target> <command> :Not enough parameters``
    """

    __slots__ = ['target', 'command']

    def __init__(self, source: str, target: str, command: str) -> None:
        self.source = source
        self.target = target
        self.command = command

    def __repr__(self) -> str:
        return 'NeedMoreParams(source={}, target={}, command={})'.format(repr(self.source), repr(self.target), repr(self.command))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 461:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        command = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Not enough parameters'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, command=command)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.command))
        arguments.append(b'Not enough parameters')
        return Line(source, b"461", arguments)


class AlreadyRegistered(Message):
    """
    ``462 <target> :Unauthorized command (already registered)``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'AlreadyRegistered(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 462:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Unauthorized command (already registered)'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Unauthorized command (already registered)')
        return Line(source, b"462", arguments)


class NoPermForHost(Message):
    """
    ``463 <target> :Your host isn't among the privileged``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoPermForHost(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 463:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "Your host isn't among the privileged"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b"Your host isn't among the privileged")
        return Line(source, b"463", arguments)


class PasswordMismatch(Message):
    """
    ``464 <target> :Password incorrect``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'PasswordMismatch(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 464:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Password incorrect'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Password incorrect')
        return Line(source, b"464", arguments)


class YoureBannedCreep(Message):
    """
    ``465 <target> :You are banned from this server``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'YoureBannedCreep(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 465:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'You are banned from this server'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'You are banned from this server')
        return Line(source, b"465", arguments)


class YouWillBeBanned(Message):
    """
    ``466 <target>``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'YouWillBeBanned(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 466:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 1):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        return Line(source, b"466", arguments)


class KeySet(Message):
    """
    ``467 <target> <channel> :Channel key already set``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'KeySet(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 467:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Channel key already set'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Channel key already set')
        return Line(source, b"467", arguments)


class ChannelIsFull(Message):
    """
    ``471 <target> <channel> :Cannot join channel (+l)``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'ChannelIsFull(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 471:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Cannot join channel (+l)'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Cannot join channel (+l)')
        return Line(source, b"471", arguments)


class UnknownMode(Message):
    """
    ``472 <target> <char> :is unknown mode char to me``
    """

    __slots__ = ['target', 'char']

    def __init__(self, source: str, target: str, char: str) -> None:
        self.source = source
        self.target = target
        self.char = char

    def __repr__(self) -> str:
        return 'UnknownMode(source={}, target={}, char={})'.format(repr(self.source), repr(self.target), repr(self.char))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 472:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        char = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'is unknown mode char to me'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, char=char)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.char))
        arguments.append(b'is unknown mode char to me')
        return Line(source, b"472", arguments)


class InviteOnlyChan(Message):
    """
    ``473 <target> <channel> :Cannot join channel (+i)``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'InviteOnlyChan(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 473:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Cannot join channel (+i)'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Cannot join channel (+i)')
        return Line(source, b"473", arguments)


class BannedFromChan(Message):
    """
    ``474 <target> <channel> :Cannot join channel (+b)``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'BannedFromChan(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 474:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Cannot join channel (+b)'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Cannot join channel (+b)')
        return Line(source, b"474", arguments)


class BadChannelKey(Message):
    """
    ``475 <target> <channel> :Cannot join channel (+k)``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'BadChannelKey(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 475:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Cannot join channel (+k)'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Cannot join channel (+k)')
        return Line(source, b"475", arguments)


class BadChanMask(Message):
    """
    ``476 <target> <channel> :Bad Channel Mask``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'BadChanMask(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 476:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Bad Channel Mask'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b'Bad Channel Mask')
        return Line(source, b"476", arguments)


class NoChanModes(Message):
    """
    ``477 <target> <channel> :Channel doesn't support modes``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'NoChanModes(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 477:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "Channel doesn't support modes"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b"Channel doesn't support modes")
        return Line(source, b"477", arguments)


class BanListFull(Message):
    """
    ``478 <target> <channel> <char> :Channel list is full``
    """

    __slots__ = ['target', 'channel', 'char']

    def __init__(self, source: str, target: str, channel: str, char: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel
        self.char = char

    def __repr__(self) -> str:
        return 'BanListFull(source={}, target={}, channel={}, char={})'.format(repr(self.source), repr(self.target), repr(self.channel), repr(self.char))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 478:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 4):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        char = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Channel list is full'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel, char=char)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(encode(self.char))
        arguments.append(b'Channel list is full')
        return Line(source, b"478", arguments)


class NoPrivileges(Message):
    """
    ``481 <target> :Permission Denied- You're not an IRC operator``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoPrivileges(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 481:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "Permission Denied- You're not an IRC operator"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b"Permission Denied- You're not an IRC operator")
        return Line(source, b"481", arguments)


class ChanOpPrivsNeeded(Message):
    """
    ``482 <target> <channel> :You're not channel operator``
    """

    __slots__ = ['target', 'channel']

    def __init__(self, source: str, target: str, channel: str) -> None:
        self.source = source
        self.target = target
        self.channel = channel

    def __repr__(self) -> str:
        return 'ChanOpPrivsNeeded(source={}, target={}, channel={})'.format(repr(self.source), repr(self.target), repr(self.channel))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 482:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 3):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        channel = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "You're not channel operator"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target, channel=channel)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(encode(self.channel))
        arguments.append(b"You're not channel operator")
        return Line(source, b"482", arguments)


class CantKillServer(Message):
    """
    ``483 <target> :You can't kill a server!``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'CantKillServer(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 483:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "You can't kill a server!"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b"You can't kill a server!")
        return Line(source, b"483", arguments)


class Restricted(Message):
    """
    ``484 <target> :Your connection is restricted!``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'Restricted(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 484:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Your connection is restricted!'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Your connection is restricted!')
        return Line(source, b"484", arguments)


class UniqOpPrivsNeeded(Message):
    """
    ``485 <target> :You're not the original channel operator``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UniqOpPrivsNeeded(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 485:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: "You're not the original channel operator"
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b"You're not the original channel operator")
        return Line(source, b"485", arguments)


class NoOperHost(Message):
    """
    ``491 <target> :No O-lines for your host``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'NoOperHost(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 491:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'No O-lines for your host'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'No O-lines for your host')
        return Line(source, b"491", arguments)


class UserModeUnknownFlag(Message):
    """
    ``501 <target> :Unknown MODE flag``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UserModeUnknownFlag(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 501:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Unknown MODE flag'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Unknown MODE flag')
        return Line(source, b"501", arguments)


class UsersDontMatch(Message):
    """
    ``502 <target> :Cannot change mode for other users``
    """

    __slots__ = ['target']

    def __init__(self, source: str, target: str) -> None:
        self.source = source
        self.target = target

    def __repr__(self) -> str:
        return 'UsersDontMatch(source={}, target={})'.format(repr(self.source), repr(self.target))

    @classmethod
    def from_line(cls, line: Line, decode: typing.Callable[[bytes], str] = lambda b: b.decode("utf-8")) -> Message:
        source = None
        if line.source is not None:
            source = decode(line.source)
        if line.command != 502:
            raise ValueError("incorrect verb")
        if not (len(line.arguments) == 2):
            raise ValueError("wrong number of arguments")
        i = 0
        target = decode(line.arguments[i])
        i += 1
        # line.arguments[i]: 'Cannot change mode for other users'
        i += 1
        assert i == len(line.arguments)
        return cls(source=source, target=target)

    def to_line(self, encode: typing.Callable[[str], bytes] = lambda s: s.encode("utf-8")) -> Line:
        source = None
        if self.source is not None:
            source = encode(self.source)
        arguments = []
        arguments.append(encode(self.target))
        arguments.append(b'Cannot change mode for other users')
        return Line(source, b"502", arguments)


from_lines_by_verb = {
    b'PASS': Passwd.from_line,
    b'NICK': Nick.from_line,
    b'USER': User.from_line,
    b'OPER': Oper.from_line,
    b'MODE': Mode.from_line,
    b'SERVICE': Service.from_line,
    b'QUIT': Quit.from_line,
    b'SQUIT': SQuit.from_line,
    b'JOIN': ChannelJoin.from_line,
    b'PART': ChannelPart.from_line,
    b'TOPIC': Topic.from_line,
    b'NAMES': Names.from_line,
    b'LIST': List.from_line,
    b'INVITE': Invite.from_line,
    b'KICK': Kick.from_line,
    b'PRIVMSG': Privmsg.from_line,
    b'NOTICE': Notice.from_line,
    b'MOTD': Motd.from_line,
    b'LUSERS': Lusers.from_line,
    b'VERSION': Version.from_line,
    b'STATS': Stats.from_line,
    b'LINKS': Links.from_line,
    b'TIME': Time.from_line,
    b'CONNECT': ServerConnect.from_line,
    b'TRACE': Trace.from_line,
    b'ADMIN': Admin.from_line,
    b'INFO': Info.from_line,
    b'SERVLIST': ServList.from_line,
    b'SQUERY': SQuery.from_line,
    b'WHO': Who.from_line,
    b'WHOIS': WhoIs.from_line,
    b'WHOWAS': WhoWas.from_line,
    b'KILL': Kill.from_line,
    b'PING': Ping.from_line,
    b'PONG': Pong.from_line,
    b'ERROR': Error.from_line,
    b'AWAY': Away.from_line,
    b'REHASH': Rehash.from_line,
    b'DIE': Die.from_line,
    b'RESTART': Restart.from_line,
    b'SUMMON': Summon.from_line,
    b'USERS': Users.from_line,
    b'WALLOPS': WallOps.from_line,
    b'USERHOST': UserHost.from_line,
    b'ISON': IsOn.from_line,
    1: Welcome.from_line,
    2: YourHost.from_line,
    3: Created.from_line,
    4: MyInfo.from_line,
    5: Bounce.from_line,
    200: TraceLinkReply.from_line,
    201: TraceConnecting.from_line,
    202: TraceHandshake.from_line,
    203: TraceUnknown.from_line,
    204: TraceOperator.from_line,
    205: TraceUser.from_line,
    206: TraceServer.from_line,
    207: TraceService.from_line,
    208: TraceNewtype.from_line,
    209: TraceClass.from_line,
    211: StatsLinkInfo.from_line,
    212: StatsCommands.from_line,
    219: StatsEnd.from_line,
    221: UserModeIs.from_line,
    234: ServListReply.from_line,
    235: ServListEnd.from_line,
    242: StatsUptime.from_line,
    243: StatsOline.from_line,
    251: LuserClient.from_line,
    252: LuserOp.from_line,
    253: LuserUnknown.from_line,
    254: LuserChannels.from_line,
    255: LuserMe.from_line,
    256: AdminMe.from_line,
    257: AdminLoc1.from_line,
    258: AdminLoc2.from_line,
    259: AdminEmail.from_line,
    261: TraceLog.from_line,
    262: TraceEnd.from_line,
    263: TryAgain.from_line,
    301: AwayReply.from_line,
    302: UserHostReply.from_line,
    303: IsOnReply.from_line,
    305: UnawayReply.from_line,
    306: NowAwayReply.from_line,
    311: WhoIsUser.from_line,
    312: WhoIsServer.from_line,
    313: WhoIsOperator.from_line,
    314: WhoWasUser.from_line,
    315: WhoEnd.from_line,
    317: WhoIsIdle.from_line,
    318: WhoIsEnd.from_line,
    319: WhoIsChannels.from_line,
    322: ListReply.from_line,
    323: ListEnd.from_line,
    324: ChannelModeIs.from_line,
    325: UniqOpIs.from_line,
    331: NoTopicReply.from_line,
    332: TopicReply.from_line,
    341: Inviting.from_line,
    342: Summoning.from_line,
    346: InviteList.from_line,
    347: InviteListEnd.from_line,
    348: ExceptList.from_line,
    349: ExceptListEnd.from_line,
    351: VersionReply.from_line,
    352: WhoReply.from_line,
    353: NamesReply.from_line,
    364: LinksReply.from_line,
    365: LinksEnd.from_line,
    366: NamesEnd.from_line,
    367: BanList.from_line,
    368: BanListEnd.from_line,
    369: WhoWasEnd.from_line,
    371: InfoReply.from_line,
    372: MotdText.from_line,
    374: InfoEnd.from_line,
    375: MotdStart.from_line,
    376: MotdEnd.from_line,
    381: YoureOper.from_line,
    382: Rehashing.from_line,
    383: YoureService.from_line,
    391: TimeReply.from_line,
    392: UsersStart.from_line,
    393: UsersReply.from_line,
    394: UsersEnd.from_line,
    395: NoUsers.from_line,
    401: NoSuchNick.from_line,
    402: NoSuchServer.from_line,
    403: NoSuchChannel.from_line,
    404: CantSendToChan.from_line,
    405: TooManyChannels.from_line,
    406: WasNoSuchNick.from_line,
    407: TooManyTargets.from_line,
    408: NoSuchService.from_line,
    409: NoOrigin.from_line,
    411: NoRecipient.from_line,
    412: NoTextToSend.from_line,
    413: NoTopLevel.from_line,
    414: WildTopLevel.from_line,
    415: BadMask.from_line,
    421: UnknownCommand.from_line,
    422: NoMotd.from_line,
    423: NoAdminInfo.from_line,
    424: FileError.from_line,
    431: NoNicknameGiven.from_line,
    432: ErroneusNickname.from_line,
    433: NicknameInUse.from_line,
    436: NickCollision.from_line,
    437: UnavailResource.from_line,
    441: UserNotInChannel.from_line,
    442: NotOnChannel.from_line,
    443: UserOnChannel.from_line,
    444: NoLogin.from_line,
    445: SummonDisabled.from_line,
    446: UsersDisabled.from_line,
    451: NotRegistered.from_line,
    461: NeedMoreParams.from_line,
    462: AlreadyRegistered.from_line,
    463: NoPermForHost.from_line,
    464: PasswordMismatch.from_line,
    465: YoureBannedCreep.from_line,
    466: YouWillBeBanned.from_line,
    467: KeySet.from_line,
    471: ChannelIsFull.from_line,
    472: UnknownMode.from_line,
    473: InviteOnlyChan.from_line,
    474: BannedFromChan.from_line,
    475: BadChannelKey.from_line,
    476: BadChanMask.from_line,
    477: NoChanModes.from_line,
    478: BanListFull.from_line,
    481: NoPrivileges.from_line,
    482: ChanOpPrivsNeeded.from_line,
    483: CantKillServer.from_line,
    484: Restricted.from_line,
    485: UniqOpPrivsNeeded.from_line,
    491: NoOperHost.from_line,
    501: UserModeUnknownFlag.from_line,
    502: UsersDontMatch.from_line,

}
